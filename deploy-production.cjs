#!/usr/bin/env node

/*
  QBTC-UNIFIED PRODUCTION DEPLOYMENT SCRIPT
  Script simplificado para deployment en producci√≥n con Supabase
*/

const { spawn, exec } = require('child_process');
const http = require('http');
const fs = require('fs');
const path = require('path');

console.log('üåå QBTC-UNIFIED PRODUCTION DEPLOYMENT');
console.log('=====================================');
console.log('üéØ Iniciando deployment en producci√≥n...');
console.log('üìç Backend: Supabase (https://hrvxsaolaxnqltomqaud.supabase.co)');
console.log('');

class ProductionDeployer {
    constructor() {
        this.config = {
            leonardoPort: 3003,
            masterPort: 3203,
            frontendPort: 8080,
            mode: 'production'
        };
        
        this.processes = new Map();
        this.deploymentStart = Date.now();
    }

    async deploy() {
        try {
            console.log('üìã PASO 1: Validaciones pre-deployment');
            await this.validateEnvironment();

            console.log('üßπ PASO 2: Limpieza de procesos previos');
            await this.cleanupPreviousProcesses();

            console.log('üóÑÔ∏è PASO 3: Verificar conectividad Supabase');
            await this.verifySupabaseConnection();

            console.log('üöÄ PASO 4: Deploying core components');
            await this.deployComponents();

            console.log('‚úÖ PASO 5: Validaci√≥n post-deployment');
            await this.validateDeployment();

            console.log('üéâ DEPLOYMENT COMPLETADO EXITOSAMENTE!');
            this.showFinalInfo();

        } catch (error) {
            console.error('‚ùå Error en deployment:', error.message);
            await this.cleanup();
            process.exit(1);
        }
    }

    async validateEnvironment() {
        // Verificar Node.js
        try {
            const { exec } = require('child_process');
            const nodeVersion = await new Promise((resolve, reject) => {
                exec('node --version', (error, stdout) => {
                    if (error) reject(error);
                    else resolve(stdout.trim());
                });
            });
            console.log(`‚úÖ Node.js detectado: ${nodeVersion}`);
        } catch (error) {
            throw new Error('Node.js no encontrado');
        }

        // Verificar archivo .env
        if (!fs.existsSync('.env')) {
            throw new Error('Archivo .env no encontrado');
        }
        console.log('‚úÖ Archivo .env encontrado');

        // Verificar archivos requeridos
        const requiredFiles = [
            'MASTER-ANTICONFLICT-LAUNCHER.js',
            'check-system-status.js'
        ];

        for (const file of requiredFiles) {
            if (!fs.existsSync(file)) {
                throw new Error(`Archivo requerido no encontrado: ${file}`);
            }
        }
        console.log('‚úÖ Archivos requeridos encontrados');
    }

    async cleanupPreviousProcesses() {
        return new Promise((resolve) => {
            exec('tasklist | findstr "node"', (error, stdout) => {
                if (stdout && stdout.includes('node.exe')) {
                    console.log('üîÑ Terminando procesos Node.js previos...');
                    exec('taskkill /F /IM node.exe', (killError) => {
                        if (!killError) {
                            console.log('‚úÖ Procesos previos terminados');
                        }
                        setTimeout(resolve, 2000);
                    });
                } else {
                    console.log('‚úÖ No hay procesos Node.js previos');
                    resolve();
                }
            });
        });
    }

    async verifySupabaseConnection() {
        try {
            console.log('üîó Verificando conexi√≥n con Supabase...');
            
            // Test de conexi√≥n b√°sico usando el m√≥dulo de integraci√≥n
            const testProcess = spawn('node', ['supabase-integration.js'], {
                stdio: 'pipe'
            });

            let output = '';
            testProcess.stdout.on('data', (data) => {
                output += data.toString();
            });

            await new Promise((resolve, reject) => {
                testProcess.on('close', (code) => {
                    if (code === 0) {
                        console.log('‚úÖ Supabase conectado exitosamente');
                        resolve();
                    } else {
                        console.log('‚ö†Ô∏è Advertencia: Supabase no disponible, continuando...');
                        resolve(); // No fallar por Supabase
                    }
                });
                
                setTimeout(() => {
                    testProcess.kill();
                    resolve();
                }, 10000); // Timeout de 10 segundos
            });

        } catch (error) {
            console.log('‚ö†Ô∏è Advertencia Supabase:', error.message);
        }
    }

    async deployComponents() {
        console.log('üåå Iniciando MASTER ANTICONFLICT LAUNCHER...');
        
        // Configurar variables de entorno
        process.env.HTTP_PORT = this.config.masterPort.toString();
        process.env.DEPLOYMENT_MODE = this.config.mode;

        // Iniciar el lanzador maestro
        const masterProcess = spawn('node', ['MASTER-ANTICONFLICT-LAUNCHER.js'], {
            stdio: ['ignore', 'pipe', 'pipe'],
            detached: false,
            env: process.env
        });

        // Guardar referencia del proceso
        this.processes.set('master', masterProcess);

        // Configurar logging
        const logStream = fs.createWriteStream('deployment-output.log', { flags: 'a' });
        const errorStream = fs.createWriteStream('deployment-error.log', { flags: 'a' });

        masterProcess.stdout.on('data', (data) => {
            const output = data.toString();
            console.log(`[MASTER] ${output.trim()}`);
            logStream.write(`[${new Date().toISOString()}] ${output}`);
        });

        masterProcess.stderr.on('data', (data) => {
            const error = data.toString();
            console.error(`[MASTER ERROR] ${error.trim()}`);
            errorStream.write(`[${new Date().toISOString()}] ERROR: ${error}`);
        });

        masterProcess.on('error', (error) => {
            console.error(`[MASTER SPAWN ERROR] ${error.message}`);
        });

        // Guardar PID
        if (masterProcess.pid) {
            fs.writeFileSync('qbtc-production.pid', masterProcess.pid.toString());
            console.log(`‚úÖ Master process iniciado (PID: ${masterProcess.pid})`);
        }

        // Esperar inicializaci√≥n
        console.log('‚è≥ Esperando inicializaci√≥n del sistema...');
        await new Promise(resolve => setTimeout(resolve, 15000));
    }

    async validateDeployment() {
        // Verificar Leonardo Consciousness
        try {
            const leonardoHealth = await this.checkEndpoint(`http://localhost:${this.config.leonardoPort}/api/health`);
            console.log('‚úÖ Leonardo Consciousness: HEALTHY');
        } catch (error) {
            console.log('‚ö†Ô∏è Leonardo Consciousness: A√∫n inicializando...');
        }

        // Verificar Sistema Unificado
        try {
            const unifiedHealth = await this.checkEndpoint(`http://localhost:${this.config.masterPort}/api/health`);
            console.log('‚úÖ Sistema Unificado: HEALTHY');
        } catch (error) {
            console.log('‚ö†Ô∏è Sistema Unificado: A√∫n inicializando...');
        }
    }

    async checkEndpoint(url) {
        return new Promise((resolve, reject) => {
            const req = http.get(url, { timeout: 3000 }, (res) => {
                if (res.statusCode === 200) {
                    resolve(true);
                } else {
                    reject(new Error(`Status code: ${res.statusCode}`));
                }
            });

            req.on('error', reject);
            req.on('timeout', () => {
                req.abort();
                reject(new Error('Timeout'));
            });
        });
    }

    showFinalInfo() {
        const deploymentTime = Math.round((Date.now() - this.deploymentStart) / 1000);
        
        console.log('');
        console.log('üéâ DEPLOYMENT COMPLETADO EXITOSAMENTE! üéâ');
        console.log('======================================');
        console.log('');
        console.log('üìä INFORMACI√ìN DEL DEPLOYMENT:');
        console.log(`  ‚Ä¢ Tiempo de deployment: ${deploymentTime} segundos`);
        console.log(`  ‚Ä¢ Puerto Leonardo: ${this.config.leonardoPort}`);
        console.log(`  ‚Ä¢ Puerto Master: ${this.config.masterPort}`);
        
        if (fs.existsSync('qbtc-production.pid')) {
            const pid = fs.readFileSync('qbtc-production.pid', 'utf8').trim();
            console.log(`  ‚Ä¢ PID del proceso: ${pid}`);
        }
        
        console.log('');
        console.log('üåê URLS DE ACCESO:');
        console.log(`  ‚Ä¢ Leonardo Dashboard: http://localhost:${this.config.leonardoPort}`);
        console.log(`  ‚Ä¢ Master Dashboard: http://localhost:${this.config.masterPort}`);
        console.log(`  ‚Ä¢ Health Check Leonardo: http://localhost:${this.config.leonardoPort}/api/health`);
        console.log(`  ‚Ä¢ Health Check Master: http://localhost:${this.config.masterPort}/api/health`);
        console.log('  ‚Ä¢ Supabase Backend: https://hrvxsaolaxnqltomqaud.supabase.co');
        
        console.log('');
        console.log('üìÇ LOGS DEL SISTEMA:');
        console.log('  ‚Ä¢ Output: deployment-output.log');
        console.log('  ‚Ä¢ Errores: deployment-error.log');
        
        console.log('');
        console.log('üîß COMANDOS DE CONTROL:');
        console.log('  ‚Ä¢ Estado: node check-system-status.js');
        console.log('  ‚Ä¢ Ver logs: type deployment-output.log');
        console.log('  ‚Ä¢ Ver errores: type deployment-error.log');
        
        if (fs.existsSync('qbtc-production.pid')) {
            console.log('  ‚Ä¢ Parar sistema: taskkill /PID [PID] /F');
        }
        
        console.log('');
        console.log('‚ú® SISTEMA LISTO PARA M√ÅXIMA EXTRACCI√ìN DE JUGO CU√ÅNTICO! ‚ú®');
        console.log('');
        console.log('üåä El sistema est√° corriendo en segundo plano');
        console.log('üìä Usa los comandos arriba para monitorear el progreso');
        console.log('');
        
        // Mostrar instrucciones para mantener vivo
        console.log('üí° IMPORTANTE: Mant√©n esta terminal abierta o el sistema se cerrar√°');
        console.log('üí° Para correr en background permanente, usa: pm2 start MASTER-ANTICONFLICT-LAUNCHER.js');
    }

    async cleanup() {
        console.log('üßπ Limpiando procesos...');
        for (const [name, process] of this.processes) {
            try {
                process.kill();
                console.log(`‚úÖ Proceso ${name} terminado`);
            } catch (error) {
                console.error(`‚ùå Error terminando proceso ${name}:`, error.message);
            }
        }
    }

    // Configurar graceful shutdown
    setupGracefulShutdown() {
        const handleShutdown = async () => {
            console.log('');
            console.log('üîÑ INICIANDO SHUTDOWN GRACEFUL...');
            await this.cleanup();
            console.log('üîí SISTEMA CERRADO');
            process.exit(0);
        };

        process.on('SIGINT', handleShutdown);
        process.on('SIGTERM', handleShutdown);
    }
}

// Ejecutar deployment
async function main() {
    const deployer = new ProductionDeployer();
    deployer.setupGracefulShutdown();
    
    try {
        await deployer.deploy();
        
        // Mantener el proceso vivo para que el sistema siga corriendo
        console.log('üîÑ Manteniendo sistema activo... (Ctrl+C para cerrar)');
        
        // Mantener vivo indefinidamente
        setInterval(() => {
            // Verificaci√≥n de salud peri√≥dica cada 30 segundos
        }, 30000);
        
    } catch (error) {
        console.error('üí• Error fatal en deployment:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}
