#!/usr/bin/env node

/**
 * QBTC Master Launcher
 * Selector inteligente de m√©todo de conexi√≥n para QBTC
 * Elige autom√°ticamente el mejor m√©todo disponible
 */

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

// Cargar variables de entorno
require('dotenv').config({ path: path.join(__dirname, '.env') });

class QBTCMasterLauncher {
    constructor() {
        console.log('üöÄ QBTC Master Launcher - Sistema de Conexi√≥n Inteligente');
        console.log('=======================================================');

        this.methods = {
            DIRECT: 'direct',
            HTTP_PROXY: 'http_proxy',
            SOCKS5: 'socks5',
            VPN: 'vpn'
        };

        this.config = {
            binanceApiKey: process.env.BINANCE_API_KEY,
            binanceSecretKey: process.env.BINANCE_SECRET_KEY,
            authorizedIP: '181.43.212.196',
            currentIP: null,
            preferredMethod: process.env.CONNECTION_METHOD || 'auto'
        };

        this.status = {
            methodSelected: null,
            connectionActive: false,
            binanceAccessible: false
        };
    }

    /**
     * Obtener IP actual
     */
    async getCurrentIP() {
        return new Promise((resolve) => {
            const https = require('https');

            https.get('https://api.ipify.org', (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                    this.config.currentIP = data.trim();
                    console.log(`üì° IP actual detectada: ${this.config.currentIP}`);
                    resolve(this.config.currentIP);
                });
            }).on('error', () => {
                // Fallback
                this.config.currentIP = 'unknown';
                resolve('unknown');
            });
        });
    }

    /**
     * Verificar si la IP actual est√° autorizada
     */
    isCurrentIPAuthorized() {
        return this.config.currentIP === this.config.authorizedIP;
    }

    /**
     * Probar conexi√≥n directa con Binance
     */
    async testDirectConnection() {
        console.log('üîç Probando conexi√≥n directa...');

        try {
            const https = require('https');
            const crypto = require('crypto');

            const timestamp = Date.now();
            const queryString = `timestamp=${timestamp}&recvWindow=5000`;
            const signature = crypto.createHmac('sha256', this.config.binanceSecretKey)
                .update(queryString)
                .digest('hex');

            const options = {
                hostname: 'fapi.binance.com',
                path: `/fapi/v2/account?${queryString}&signature=${signature}`,
                method: 'GET',
                headers: {
                    'X-MBX-APIKEY': this.config.binanceApiKey,
                    'User-Agent': 'QBTC-Master-Launcher/1.0'
                },
                timeout: 10000
            };

            return new Promise((resolve) => {
                const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', chunk => data += chunk);
                    res.on('end', () => {
                        try {
                            const response = JSON.parse(data);
                            if (res.statusCode === 200) {
                                console.log('‚úÖ Conexi√≥n directa exitosa');
                                resolve({ success: true, method: 'DIRECT', response });
                            } else if (response.code === -2015) {
                                console.log('‚ùå IP no autorizada para conexi√≥n directa');
                                resolve({ success: false, method: 'DIRECT', error: 'IP_NOT_AUTHORIZED' });
                            } else {
                                console.log(`‚ùå Error en conexi√≥n directa: ${response.msg}`);
                                resolve({ success: false, method: 'DIRECT', error: response.msg });
                            }
                        } catch (e) {
                            resolve({ success: false, method: 'DIRECT', error: 'PARSE_ERROR' });
                        }
                    });
                });

                req.on('error', () => {
                    resolve({ success: false, method: 'DIRECT', error: 'CONNECTION_ERROR' });
                });

                req.on('timeout', () => {
                    req.destroy();
                    resolve({ success: false, method: 'DIRECT', error: 'TIMEOUT' });
                });

                req.end();
            });

        } catch (error) {
            console.log('‚ùå Error probando conexi√≥n directa:', error.message);
            return { success: false, method: 'DIRECT', error: error.message };
        }
    }

    /**
     * Verificar disponibilidad de m√©todos
     */
    async checkMethodAvailability() {
        console.log('üîç Verificando disponibilidad de m√©todos...');

        const availability = {
            direct: false,
            http_proxy: false,
            socks5: false,
            vpn: false
        };

        // Verificar conexi√≥n directa
        const directTest = await this.testDirectConnection();
        availability.direct = directTest.success;

        // Verificar proxy HTTP (puerto 8888)
        try {
            const net = require('net');
            availability.http_proxy = await new Promise((resolve) => {
                const client = net.createConnection({ port: 8888, host: '127.0.0.1' });
                client.on('connect', () => {
                    client.end();
                    resolve(true);
                });
                client.on('error', () => resolve(false));
                setTimeout(() => {
                    client.end();
                    resolve(false);
                }, 2000);
            });
        } catch (e) {
            availability.http_proxy = false;
        }

        // Verificar SOCKS5 (simular conexi√≥n)
        try {
            const { SocksProxyAgent } = require('socks-proxy-agent');
            const agent = new SocksProxyAgent(`socks5://${this.config.authorizedIP}:1080`);
            availability.socks5 = true; // Asumir disponible si la librer√≠a carga
        } catch (e) {
            availability.socks5 = false;
        }

        // Verificar VPN (interfaces de red)
        const os = require('os');
        const networkInterfaces = os.networkInterfaces();
        availability.vpn = Object.keys(networkInterfaces).some(iface =>
            iface.toLowerCase().includes('vpn') ||
            iface.toLowerCase().includes('tun') ||
            iface.toLowerCase().includes('tap')
        );

        console.log('üìä Disponibilidad de m√©todos:');
        Object.entries(availability).forEach(([method, available]) => {
            console.log(`   ${method}: ${available ? '‚úÖ' : '‚ùå'}`);
        });

        return availability;
    }

    /**
     * Seleccionar mejor m√©todo autom√°ticamente
     */
    async selectBestMethod() {
        console.log('üéØ Seleccionando mejor m√©todo de conexi√≥n...');

        const availability = await this.checkMethodAvailability();

        // Estrategia de selecci√≥n
        if (availability.direct) {
            console.log('‚úÖ M√©todo seleccionado: DIRECT (IP ya autorizada)');
            return this.methods.DIRECT;
        }

        if (availability.socks5) {
            console.log('‚úÖ M√©todo seleccionado: SOCKS5 (cambia IP real)');
            return this.methods.SOCKS5;
        }

        if (availability.vpn) {
            console.log('‚úÖ M√©todo seleccionado: VPN (conexi√≥n VPN activa)');
            return this.methods.VPN;
        }

        if (availability.http_proxy) {
            console.log('‚ö†Ô∏è M√©todo seleccionado: HTTP_PROXY (solo headers)');
            return this.methods.HTTP_PROXY;
        }

        console.log('‚ùå No hay m√©todos disponibles, usando DIRECT como fallback');
        return this.methods.DIRECT;
    }

    /**
     * Ejecutar m√©todo seleccionado
     */
    async executeSelectedMethod(method) {
        console.log(`üöÄ Ejecutando m√©todo: ${method}`);

        let scriptName;

        switch (method) {
            case this.methods.DIRECT:
                scriptName = 'system-integrator.cjs';
                break;
            case this.methods.HTTP_PROXY:
                scriptName = 'qbtc-with-correct-ip.cjs';
                break;
            case this.methods.SOCKS5:
                scriptName = 'qbtc-socks5-proxy.cjs';
                break;
            case this.methods.VPN:
                scriptName = 'qbtc-vpn-connector.cjs';
                break;
            default:
                scriptName = 'system-integrator.cjs';
        }

        console.log(`üìÅ Ejecutando script: ${scriptName}`);

        return new Promise((resolve, reject) => {
            const child = spawn('node', [scriptName], {
                stdio: 'inherit',
                cwd: __dirname,
                env: {
                    ...process.env,
                    SELECTED_METHOD: method,
                    MASTER_LAUNCHER: 'true'
                }
            });

            child.on('close', (code) => {
                console.log(`\nüîÑ Script ${scriptName} terminado con c√≥digo: ${code}`);
                resolve(code);
            });

            child.on('error', (error) => {
                console.error(`‚ùå Error ejecutando ${scriptName}:`, error);
                reject(error);
            });
        });
    }

    /**
     * M√©todo principal
     */
    async launch() {
        try {
            console.log('üåü INICIANDO QBTC MASTER LAUNCHER');
            console.log('==================================');

            // Obtener IP actual
            await this.getCurrentIP();

            // Verificar si IP est√° autorizada
            if (this.isCurrentIPAuthorized()) {
                console.log('üéâ IP actual est√° autorizada en Binance');
                this.status.methodSelected = this.methods.DIRECT;
            } else {
                console.log('‚ö†Ô∏è IP actual NO est√° autorizada, buscando alternativas...');

                // Seleccionar mejor m√©todo
                if (this.config.preferredMethod === 'auto') {
                    this.status.methodSelected = await this.selectBestMethod();
                } else {
                    this.status.methodSelected = this.config.preferredMethod;
                    console.log(`üéØ M√©todo forzado por configuraci√≥n: ${this.status.methodSelected}`);
                }
            }

            // Mostrar resumen
            console.log('\nüìã RESUMEN DE CONEXI√ìN:');
            console.log('=======================');
            console.log(`IP Actual: ${this.config.currentIP}`);
            console.log(`IP Autorizada: ${this.config.authorizedIP}`);
            console.log(`M√©todo Seleccionado: ${this.status.methodSelected}`);
            console.log(`Credenciales: ${this.config.binanceApiKey ? '‚úÖ' : '‚ùå'}`);

            // Ejecutar m√©todo seleccionado
            console.log('\nüöÄ EJECUTANDO SISTEMA QBTC...');
            const exitCode = await this.executeSelectedMethod(this.status.methodSelected);

            return exitCode;

        } catch (error) {
            console.error('‚ùå Error en Master Launcher:', error);
            throw error;
        }
    }

    /**
     * Obtener estado del sistema
     */
    getStatus() {
        return {
            ...this.status,
            config: this.config,
            timestamp: Date.now()
        };
    }
}

// Funci√≥n para mostrar men√∫ interactivo
function showMenu() {
    console.log('\nüéõÔ∏è QBTC MASTER LAUNCHER - MEN√ö');
    console.log('==============================');
    console.log('1. üöÄ Auto (detectar mejor m√©todo)');
    console.log('2. üîó Direct (IP actual)');
    console.log('3. üåê HTTP Proxy (headers)');
    console.log('4. üîí SOCKS5 Proxy (IP real)');
    console.log('5. üõ°Ô∏è VPN (conexi√≥n VPN)');
    console.log('6. üìä Estado del sistema');
    console.log('7. ‚ùå Salir');
    console.log('==============================');
}

// Funci√≥n principal interactiva
async function interactiveMode() {
    const launcher = new QBTCMasterLauncher();

    while (true) {
        showMenu();

        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        const answer = await new Promise(resolve => {
            rl.question('Selecciona una opci√≥n (1-7): ', resolve);
        });

        rl.close();

        try {
            switch (answer.trim()) {
                case '1':
                    console.log('\nüöÄ Modo AUTO seleccionado');
                    await launcher.launch();
                    break;
                case '2':
                    console.log('\nüîó Modo DIRECT seleccionado');
                    launcher.config.preferredMethod = launcher.methods.DIRECT;
                    await launcher.executeSelectedMethod(launcher.methods.DIRECT);
                    break;
                case '3':
                    console.log('\nüåê Modo HTTP_PROXY seleccionado');
                    launcher.config.preferredMethod = launcher.methods.HTTP_PROXY;
                    await launcher.executeSelectedMethod(launcher.methods.HTTP_PROXY);
                    break;
                case '4':
                    console.log('\nüîí Modo SOCKS5 seleccionado');
                    launcher.config.preferredMethod = launcher.methods.SOCKS5;
                    await launcher.executeSelectedMethod(launcher.methods.SOCKS5);
                    break;
                case '5':
                    console.log('\nüõ°Ô∏è Modo VPN seleccionado');
                    launcher.config.preferredMethod = launcher.methods.VPN;
                    await launcher.executeSelectedMethod(launcher.methods.VPN);
                    break;
                case '6':
                    console.log('\nüìä Estado del sistema:');
                    console.log(JSON.stringify(launcher.getStatus(), null, 2));
                    break;
                case '7':
                    console.log('\nüëã ¬°Hasta luego!');
                    process.exit(0);
                    break;
                default:
                    console.log('\n‚ùå Opci√≥n no v√°lida');
            }
        } catch (error) {
            console.error('\n‚ùå Error:', error.message);
        }

        // Pausa antes de mostrar men√∫ nuevamente
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// Exportar la clase
module.exports = { QBTCMasterLauncher };

// Si se ejecuta directamente
if (require.main === module) {
    // Verificar si hay argumentos de l√≠nea de comandos
    const args = process.argv.slice(2);

    if (args.includes('--auto') || args.includes('-a')) {
        // Modo autom√°tico
        const launcher = new QBTCMasterLauncher();
        launcher.launch()
            .then(() => {
                console.log('üéâ QBTC Master Launcher completado');
            })
            .catch(error => {
                console.error('‚ùå Error en Master Launcher:', error);
                process.exit(1);
            });
    } else if (args.includes('--interactive') || args.includes('-i')) {
        // Modo interactivo
        interactiveMode();
    } else {
        // Mostrar ayuda
        console.log('üéõÔ∏è QBTC Master Launcher');
        console.log('======================');
        console.log('Uso:');
        console.log('  node qbtc-master-launcher.cjs --auto        # Modo autom√°tico');
        console.log('  node qbtc-master-launcher.cjs --interactive # Modo interactivo');
        console.log('  node qbtc-master-launcher.cjs               # Esta ayuda');
        console.log('');
        console.log('M√©todos disponibles:');
        console.log('  üîó DIRECT: Conexi√≥n directa (requiere IP autorizada)');
        console.log('  üåê HTTP_PROXY: Proxy HTTP (modifica headers)');
        console.log('  üîí SOCKS5: Proxy SOCKS5 (cambia IP real)');
        console.log('  üõ°Ô∏è VPN: Conexi√≥n VPN autom√°tica');
        process.exit(0);
    }

    // Manejar se√±ales de terminaci√≥n
    process.on('SIGINT', () => {
        console.log('\nüîÑ Master Launcher detenido por SIGINT');
        process.exit(0);
    });

    process.on('SIGTERM', () => {
        console.log('\nüîÑ Master Launcher detenido por SIGTERM');
        process.exit(0);
    });
}