/*
  Copyright ¬© 2025 VIGOLEONROCKS QUANTUM TECHNOLOGIES.
  Quantum Market Maker - Market Maker Cu√°ntico sin l√≠mites determin√≠sticos
  Ingenier√≠a inversa para explotar el edge cu√°ntico en TODOS los s√≠mbolos de Binance
*/

const { connector: sharedConnector, BinanceRealConnector } = require('./BinanceRealConnector');
const { QuantumLeverageEngine } = require('./QuantumLeverageEngine');
const { QuantumProfitMaximizer } = require('./QuantumProfitMaximizer');
const { QuantumNxNMatrix } = require('./QuantumNxNMatrix');

class QuantumMarketMaker {
    constructor(existingConnector = null) {
        // **VISI√ìN CU√ÅNTICA**: Market Maker sin l√≠mites determin√≠sticos
        // Usa el conector singleton compartido por defecto
        this.binanceConnector = existingConnector || sharedConnector || new BinanceRealConnector();
        this.leverageEngine = new QuantumLeverageEngine(this.binanceConnector);
        
        // **PROFIT MAXIMIZER**: Algoritmo de profit m√°ximo con ingenier√≠a inversa
        this.profitMaximizer = new QuantumProfitMaximizer(this, this.leverageEngine, this.binanceConnector);

        // **MATRIZ NxN**: Espacio infinito de rentabilidad z=9+16j, log7919, Œª=888
        this.nxnMatrix = new QuantumNxNMatrix(this.binanceConnector);
        
        // **INGENIER√çA INVERSA**: Explotar TODOS los s√≠mbolos disponibles
        this.allBinanceSymbols = new Set();
        this.symbolsMetrics = new Map();
        this.arbitrageOpportunities = new Map();
        this.crossPairEdges = new Map();
        
        // **EDGE CU√ÅNTICO**: Matrices de correlaci√≥n multidimensional
        this.quantumCorrelationMatrix = new Map();
        this.temporalArbitrageMatrix = new Map();
        this.volatilityArbitrageMatrix = new Map();
        
        // **LEVERAGE DIN√ÅMICO**: Sin l√≠mites fijos, basado en edge cu√°ntico
        this.dynamicLeverageMap = new Map();
        this.edgeConfidenceMap = new Map();
        this.profitPotentialMap = new Map();
        
        // **PROFIT MAXIMIZATION**: Estrategias paralelas simult√°neas
        this.activeStrategies = new Map();
        this.profitStreams = new Map();
        this.quantumPositions = new Map();
        
        // **MARKET MAKER CU√ÅNTICO**: Configuraci√≥n sin l√≠mites
        this.marketMakerConfig = {
            maxSymbolsSimultaneous: 2000,        // TODOS los s√≠mbolos
            maxLeverageQuantum: 125,              // Leverage cu√°ntico m√°ximo
            minProfitThreshold: 0.001,            // 0.1% m√≠nimo
            maxDrawdownQuantum: 0.15,             // 15% m√°ximo
            quantumSpeedExecution: 50,            // 50ms ejecuci√≥n
            arbitrageTimeWindow: 100,             // 100ms ventana
            edgeDetectionSensitivity: 0.0001,    // Detectar 0.01% edges
            profitReinvestmentRatio: 0.95         // 95% reinversi√≥n
        };
        
        // **M√âTRICAS DE RENDIMIENTO CU√ÅNTICO**
        this.performanceMetrics = {
            totalSymbolsExploited: 0,
            totalArbitrageExecuted: 0,
            totalProfitGenerated: 0,
            averageLeverageUsed: 0,
            edgeDetectionRate: 0,
            quantumSuccessRate: 0,
            maxSimultaneousPositions: 0,
            profitPerSecond: 0
        };
        
        console.log('[QUANTUM MARKET MAKER] Inicializando Market Maker Cu√°ntico sin l√≠mites...');
        this.initialize();
    }

    async initialize() {
        try {
            console.log('[QUANTUM MARKET MAKER] üöÄ INICIANDO INGENIER√çA INVERSA CU√ÅNTICA');
            
            // **VALIDACI√ìN INICIAL**
            const apiConfig = await this.validateAPIConfiguration();
            if (!apiConfig.valid) {
                throw new Error(`Error de configuraci√≥n API: ${apiConfig.error}`);
            }
            
            // **PASO 1**: Obtener TODOS los s√≠mbolos de Binance
            const maxRetries = 3;
            let symbols = null;
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    symbols = await this.fetchAllBinanceSymbols();
                    if (symbols && symbols.length > 0) break;
                    retryCount++;
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                } catch (error) {
                    console.warn(`[QUANTUM MARKET MAKER] Intento ${retryCount + 1}/${maxRetries} fallido:`, error.message);
                    retryCount++;
                    if (retryCount === maxRetries) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                }
            }
            
            if (!symbols || symbols.length === 0) {
                throw new Error('No se pudieron obtener s√≠mbolos despu√©s de m√∫ltiples intentos');
            }
            
            console.log(`[QUANTUM MARKET MAKER] ‚úÖ ${symbols.length} s√≠mbolos obtenidos exitosamente`);
            
            // **PASO 2**: Inicializar m√©tricas en tiempo real para TODOS
            await this.initializeAllSymbolsMetrics();
            
            // **VALIDACI√ìN DE M√âTRICAS**
            const metricsValidation = this.validateMetrics();
            if (!metricsValidation.valid) {
                throw new Error(`Error en m√©tricas: ${metricsValidation.error}`);
            }
            
            // **PASO 3**: Calcular matrices de correlaci√≥n cu√°ntica
            await this.calculateQuantumCorrelationMatrices();
            
            // **PASO 4**: Detectar oportunidades de arbitraje inicial
            await this.scanForArbitrageOpportunities();
            
            // **PASO 5**: Iniciar motor de market making cu√°ntico
            this.startQuantumMarketMaking();
            
            console.log(`[QUANTUM MARKET MAKER] ‚úÖ SISTEMA ACTIVADO - ${this.allBinanceSymbols.size} s√≠mbolos bajo control cu√°ntico`);
            
        } catch (error) {
            console.error('[QUANTUM MARKET MAKER] ‚ùå Error cr√≠tico inicializando:', error.message);
            throw error; // Propagar error para manejo superior
        }
    }

    async validateAPIConfiguration() {
        try {
            // Modo desarrollo - saltar validaci√≥n API
            if (process.env.DEVELOPMENT_MODE === 'true' || process.env.SKIP_API_VALIDATION === 'true') {
                console.log('[QUANTUM MARKET MAKER] üîß Modo desarrollo - Validaci√≥n API omitida');
                return { valid: true, development: true };
            }
            
            // Validar conexi√≥n base (evitar llamadas duplicadas si ya est√° conectado)
            if (!this.binanceConnector.isConnected) {
                await this.binanceConnector.testConnection();
            }
            
            // Validar credenciales
            if (!this.binanceConnector.apiKey || !this.binanceConnector.secretKey) {
                return { valid: false, error: 'Credenciales API no configuradas' };
            }
            
            // Validar permisos (intentar obtener account info)
            const accountInfo = await this.binanceConnector.getAccountInfo();
            if (!accountInfo) {
                return { valid: false, error: 'No se pudo obtener informaci√≥n de cuenta' };
            }
            
            return { valid: true };
            
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }

    validateMetrics() {
        // Validar que tenemos m√©tricas b√°sicas para operar
        if (this.symbolsMetrics.size === 0) {
            return { valid: false, error: 'No hay m√©tricas inicializadas' };
        }
        
        // Validar que al menos 50% de los s√≠mbolos tienen m√©tricas completas
        const totalSymbols = this.allBinanceSymbols.size;
        const symbolsWithMetrics = Array.from(this.symbolsMetrics.entries())
            .filter(([_, metrics]) => (
                metrics.price && 
                metrics.volume24h && 
                metrics.volatility && 
                metrics.quantumLeverage
            )).length;
        
        const metricsRatio = symbolsWithMetrics / totalSymbols;
        
        if (metricsRatio < 0.5) {
            return { 
                valid: false, 
                error: `Solo ${(metricsRatio * 100).toFixed(1)}% de s√≠mbolos tienen m√©tricas completas` 
            };
        }
        
        return { valid: true };
    }

    async fetchAllBinanceSymbols() {
        try {
            console.log('[QUANTUM MARKET MAKER] üì° Obteniendo universo de s√≠mbolos (connector/exchange)...');

            // Modo desarrollo - usar s√≠mbolos simulados
            if (process.env.DEVELOPMENT_MODE === 'true' || process.env.SKIP_API_VALIDATION === 'true') {
                console.log('[QUANTUM MARKET MAKER] üîß Modo desarrollo - Usando s√≠mbolos simulados');
                return this.generateDevelopmentSymbols();
            }

            // Intentar universo desde el conector (respeta QUANTUM_MAX_SYMBOLS)
            try {
                if (this.binanceConnector && typeof this.binanceConnector.getSymbolsUniverse === 'function') {
                    const limitEnv = process.env.QUANTUM_MAX_SYMBOLS;
                    let limit = null;
                    if (limitEnv !== undefined) {
                        const n = parseInt(String(limitEnv), 10);
                        if (Number.isFinite(n)) {
                            limit = n === 0 ? Number.MAX_SAFE_INTEGER : Math.max(1, n);
                        }
                    }
                    const fromConnector = this.binanceConnector.getSymbolsUniverse(limit);
                    if (Array.isArray(fromConnector) && fromConnector.length > 0) {
                        // Limpiar datos anteriores
                        this.allBinanceSymbols.clear();
                        this.symbolsMetrics.clear();

                        for (const symbol of fromConnector) {
                            this.allBinanceSymbols.add(symbol);

                            // An√°lisis inicial de potencial cu√°ntico
                            const quantumPotential = this.analyzeQuantumPotential(symbol);
                            this.symbolsMetrics.set(symbol, {
                                quantumPotential,
                                lastUpdate: Date.now(),
                                isActive: false,
                                leverageScore: 0,
                                profitScore: 0,
                                riskScore: 0,
                                initializedAt: Date.now()
                            });
                        }

                        console.log(`[QUANTUM MARKET MAKER] ‚úÖ Universo obtenido desde conector: ${this.allBinanceSymbols.size} s√≠mbolos`);
                        return Array.from(this.allBinanceSymbols);
                    }
                }
            } catch (connectorErr) {
                console.warn('[QUANTUM MARKET MAKER] Warning: getSymbolsUniverse fall√≥, se usar√° exchangeInfo:', connectorErr && connectorErr.message);
            }

            // Fallback: exchangeInfo
            const response = await this.binanceConnector.makeRequest('GET', '/fapi/v1/exchangeInfo');
            if (!response || !response.symbols) {
                throw new Error('Respuesta de API inv√°lida - no hay s√≠mbolos');
            }

            let allSymbols = response.symbols
                .filter(symbol =>
                    symbol.status === 'TRADING' &&
                    symbol.contractType === 'PERPETUAL' // Solo futuros perpetuos
                )
                .map(symbol => symbol.symbol);

            // Aplicar QUANTUM_MAX_SYMBOLS si corresponde
            const envMax = process.env.QUANTUM_MAX_SYMBOLS;
            if (envMax !== undefined) {
                const n = parseInt(String(envMax), 10);
                if (Number.isFinite(n)) {
                    if (n > 0) {
                        allSymbols = allSymbols.slice(0, n);
                    } // n === 0 => sin l√≠mite
                }
            }

            if (allSymbols.length === 0) {
                throw new Error('No se encontraron s√≠mbolos de trading activos');
            }

            // Limpiar datos anteriores
            this.allBinanceSymbols.clear();
            this.symbolsMetrics.clear();

            for (const symbol of allSymbols) {
                this.allBinanceSymbols.add(symbol);

                const quantumPotential = this.analyzeQuantumPotential(symbol);
                this.symbolsMetrics.set(symbol, {
                    quantumPotential,
                    lastUpdate: Date.now(),
                    isActive: false,
                    leverageScore: 0,
                    profitScore: 0,
                    riskScore: 0,
                    initializedAt: Date.now()
                });
            }

            console.log(`[QUANTUM MARKET MAKER] üéØ ${this.allBinanceSymbols.size} s√≠mbolos identificados (exchange)`);
            return allSymbols;

        } catch (error) {
            console.error('[QUANTUM MARKET MAKER] Error cr√≠tico obteniendo s√≠mbolos:', error.message);
            throw error; // Propagar error
        }
    }

    // **GENERAR S√çMBOLOS SIMULADOS PARA DESARROLLO**
    generateDevelopmentSymbols() {
        console.log('[QUANTUM MARKET MAKER] üîß Generando s√≠mbolos simulados para desarrollo...');
        
        // Lista de desarrollo optimizada y expandida (40 s√≠mbolos)
        const developmentSymbols = [
            // Majors (10) - Potencial cu√°ntico alto
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
            'XRPUSDT', 'DOTUSDT', 'AVAXUSDT', 'MATICUSDT', 'LINKUSDT',
            
            // Meme coins (10) - Volatilidad extrema
            'DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', '1000FLOKIUSDT', 'WIFUSDT',
            'BONKUSDT', 'BOMEUSDT', 'MEMEUSDT', '1000RATSUSDT', '1000SATSUSDT',
            
            // Dark side (10) - Arbitraje potencial
            'ORDIUSDT', 'INJUSDT', 'STXUSDT', 'JUPUSDT', 'TNSRUSDT',
            'PYUSDT', 'ALTUSDT', 'ARKUSDT', 'PIXELUSDT', 'ACEUSDT',
            
            // Exotics (10) - Diversificaci√≥n
            'APTUSDT', 'NEARUSDT', 'FTMUSDT', 'ATOMUSDT', 'ICPUSDT',
            'ALGOUSDT', 'HBARUSDT', 'VETUSDT', 'XMRUSDT', 'FILUSDT'
        ];
        
        // Limpiar datos anteriores
        this.allBinanceSymbols.clear();
        this.symbolsMetrics.clear();
        
        // Agregar s√≠mbolos simulados con m√©tricas b√°sicas
        for (const symbol of developmentSymbols) {
            this.allBinanceSymbols.add(symbol);
            
            // Generar m√©tricas simuladas
            const quantumPotential = this.analyzeQuantumPotential(symbol);
            this.symbolsMetrics.set(symbol, {
                quantumPotential,
                price: this.calculateDeterministicValue('price', symbol, 1, 1000), // Precio entre 1-1000
                volume24h: this.calculateDeterministicValue('volume24h', symbol, 100000, 10000000), // Volumen simulado
                priceChange24h: (this.calculateDeterministicValue('priceChange24h', symbol, 0, 1) - 0.5) * 20, // Cambio ¬±10%
                volatility: this.calculateDeterministicValue('volatility', symbol, 0, 0.15), // Volatilidad 0-15%
                spread: this.calculateDeterministicValue('spread', symbol, 0, 0.01), // Spread 0-1%
                liquidityScore: this.calculateDeterministicValue('liquidityScore', symbol, 0, 100), // Score 0-100
                arbitrageScore: this.calculateDeterministicValue('arbitrageScore', symbol, 0, 100), // Score 0-100
                quantumLeverage: this.calculateDeterministicValue('quantumLeverage', symbol, 1, 125), // Leverage 1-125
                profitPotential: this.calculateDeterministicValue('profitPotential', symbol, 0, 1000), // Profit potencial
                riskAdjustedScore: this.calculateDeterministicValue('riskAdjustedScore', symbol, 0, 100), // Score ajustado por riesgo
                lastUpdate: Date.now(),
                isActive: true,
                leverageScore: this.calculateDeterministicValue('leverageScore', symbol, 0, 100),
                profitScore: this.calculateDeterministicValue('profitScore', symbol, 0, 100),
                riskScore: this.calculateDeterministicValue('riskScore', symbol, 0, 100),
                initializedAt: Date.now(),
                developmentMode: true
            });
        }
        
        console.log(`[QUANTUM MARKET MAKER] ‚úÖ ${developmentSymbols.length} s√≠mbolos simulados generados`);
        return developmentSymbols;
    }

    analyzeQuantumPotential(symbol) {
        // **AN√ÅLISIS CU√ÅNTICO**: Determinar potencial de cada s√≠mbolo
        let score = 0;
        
        // Factor 1: Liquidez potencial (basado en patrones)
        if (symbol.includes('USDT')) score += 10;
        if (symbol.includes('BTC')) score += 8;
        if (symbol.includes('ETH')) score += 6;
        
        // Factor 2: Volatilidad potencial (basado en tipo)
        const volatileKeywords = ['SHIB', 'DOGE', 'PEPE', 'MEME', '1000', 'RATS', 'SATS'];
        const isVolatile = volatileKeywords.some(keyword => symbol.includes(keyword));
        if (isVolatile) score += 15;
        
        // Factor 3: Arbitraje potencial (pares cruzados)
        const crossPairs = ['BTC', 'ETH', 'BNB', 'USDT', 'BUSD'];
        const crossPotential = crossPairs.filter(pair => symbol.includes(pair)).length;
        score += crossPotential * 5;
        
        // Factor 4: Market cap potencial
        const majorCoins = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'MATIC', 'DOT', 'AVAX'];
        const isMajor = majorCoins.some(major => symbol.includes(major));
        if (isMajor) score += 12;
        
        return Math.min(score, 100); // Normalizar a 0-100
    }

    async initializeAllSymbolsMetrics() {
        console.log('[QUANTUM MARKET MAKER] üìÅ Inicializando m√©tricas para TODOS los s√≠mbolos...');
        
        // Modo desarrollo - saltar inicializaci√≥n de m√©tricas API
        if (process.env.DEVELOPMENT_MODE === 'true' || process.env.SKIP_API_VALIDATION === 'true') {
            console.log('[QUANTUM MARKET MAKER] üîß Modo desarrollo - M√©tricas ya generadas con s√≠mbolos simulados');
            return;
        }
        
        const batchSize = 100; // Procesar en lotes para no sobrecargar
        const symbols = Array.from(this.allBinanceSymbols);
        
        for (let i = 0; i < symbols.length; i += batchSize) {
            const batch = symbols.slice(i, i + batchSize);
            
            const batchPromises = batch.map(symbol => this.initializeSymbolMetrics(symbol));
            await Promise.allSettled(batchPromises);
            
            console.log(`[QUANTUM MARKET MAKER] ‚ö° Procesados ${Math.min(i + batchSize, symbols.length)}/${symbols.length} s√≠mbolos`);
            
            // Pausa para no saturar la API
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        console.log('[QUANTUM MARKET MAKER] ‚úÖ M√©tricas inicializadas para todos los s√≠mbolos');
    }

    async initializeSymbolMetrics(symbol) {
        try {
            // Obtener datos b√°sicos del s√≠mbolo
            const ticker = await this.binanceConnector.makeRequest('GET', '/fapi/v1/ticker/24hr', { symbol });
            
            if (ticker) {
                const metrics = this.symbolsMetrics.get(symbol) || {};
                
                metrics.price = parseFloat(ticker.lastPrice);
                metrics.volume24h = parseFloat(ticker.volume);
                metrics.priceChange24h = parseFloat(ticker.priceChangePercent);
                metrics.volatility = Math.abs(parseFloat(ticker.priceChangePercent));
                metrics.spread = this.calculateSpread(ticker);
                metrics.liquidityScore = this.calculateLiquidityScore(ticker);
                metrics.arbitrageScore = await this.calculateArbitrageScore(symbol, ticker);
                
                // **EDGE CU√ÅNTICO**: Calcular potencial de leverage din√°mico
                metrics.quantumLeverage = this.calculateQuantumLeverage(metrics);
                metrics.profitPotential = this.calculateProfitPotential(metrics);
                metrics.riskAdjustedScore = this.calculateRiskAdjustedScore(metrics);
                
                this.symbolsMetrics.set(symbol, metrics);
            }
            
        } catch (error) {
            // Silencioso para s√≠mbolos que no respondan
            if (error.message.includes('Invalid symbol')) return;
            console.warn(`[QUANTUM MARKET MAKER] Warning: ${symbol} - ${error.message}`);
        }
    }

    calculateSpread(ticker) {
        const bid = parseFloat(ticker.bidPrice) || 0;
        const ask = parseFloat(ticker.askPrice) || 0;
        if (bid === 0 || ask === 0) return 0;
        return ((ask - bid) / bid) * 100;
    }

    calculateLiquidityScore(ticker) {
        const volume = parseFloat(ticker.volume) || 0;
        const count = parseFloat(ticker.count) || 1;
        
        // Score basado en volumen y n√∫mero de trades
        return Math.min((volume / 1000000) + (count / 10000), 100);
    }
    
    calculateMomentumEdge(symbol, metrics) {
        const priceChange = Math.abs(metrics.priceChange24h || 0) / 100;
        const volumeConfirmation = Math.min(metrics.volume24h / 5000000, 0.02);
        const volatilityBoost = Math.min(metrics.volatility * 2, 0.05);
        
        return priceChange + volumeConfirmation + volatilityBoost;
    }
    
    calculateVolatilityEdge(symbol, metrics) {
        return metrics.volatility || 0;
    }
    
    calculateMeanReversionEdge(symbol, metrics) {
        // Edge cuando el precio se desv√≠a mucho del promedio
        const priceDeviation = Math.abs(metrics.priceChange24h || 0) / 100;
        const volumeAnomaly = metrics.volume24h > 20000000 ? 0.01 : 0;
        
        return priceDeviation > 0.1 ? priceDeviation + volumeAnomaly : 0;
    }
    
    calculateBreakoutEdge(symbol, metrics) {
        // Edge basado en patrones de breakout
        const volumeSpike = metrics.volume24h > 15000000 ? 0.02 : 0;
        const priceBreakout = Math.abs(metrics.priceChange24h || 0) > 15 ? 0.03 : 0;
        const volatilityBreakout = metrics.volatility > 0.1 ? 0.015 : 0;
        
        return volumeSpike + priceBreakout + volatilityBreakout;
    }
    
    calculateArbitrageEdge(symbol, metrics) {
        // Edge basado en spread y diferencias de precio
        const spreadEdge = Math.max(0, (0.002 - metrics.spread)) * 1000; // Spread favorable
        const volumeEdge = Math.min(metrics.volume24h / 10000000, 0.01); // Volumen alto
        const liquidityEdge = Math.min(metrics.liquidityScore / 1000, 0.005); // Liquidez alta
        
        return spreadEdge + volumeEdge + liquidityEdge;
    }

    async calculateArbitrageScore(symbol, ticker) {
        // **ARBITRAJE CU√ÅNTICO**: Buscar oportunidades entre pares
        let arbitrageScore = 0;
        
        try {
            // Buscar pares relacionados para arbitraje triangular
            const baseCurrency = this.extractBaseCurrency(symbol);
            const quoteCurrency = this.extractQuoteCurrency(symbol);
            
            if (baseCurrency && quoteCurrency) {
                // Ejemplo: BTC/USDT -> buscar BTC/ETH y ETH/USDT para arbitraje
                const relatedPairs = this.findRelatedPairs(baseCurrency, quoteCurrency);
                arbitrageScore = relatedPairs.length * 10;
            }
            
        } catch (error) {
            arbitrageScore = 0;
        }
        
        return Math.min(arbitrageScore, 100);
    }

    extractBaseCurrency(symbol) {
        const commonQuotes = ['USDT', 'BUSD', 'BTC', 'ETH', 'BNB'];
        for (const quote of commonQuotes) {
            if (symbol.endsWith(quote)) {
                return symbol.slice(0, -quote.length);
            }
        }
        return null;
    }

    extractQuoteCurrency(symbol) {
        const commonQuotes = ['USDT', 'BUSD', 'BTC', 'ETH', 'BNB'];
        for (const quote of commonQuotes) {
            if (symbol.endsWith(quote)) {
                return quote;
            }
        }
        return null;
    }

    findRelatedPairs(baseCurrency, quoteCurrency) {
        const relatedPairs = [];
        const intermediates = ['BTC', 'ETH', 'BNB', 'USDT'];
        
        for (const intermediate of intermediates) {
            if (intermediate !== baseCurrency && intermediate !== quoteCurrency) {
                const pair1 = `${baseCurrency}${intermediate}`;
                const pair2 = `${intermediate}${quoteCurrency}`;
                
                if (this.allBinanceSymbols.has(pair1) && this.allBinanceSymbols.has(pair2)) {
                    relatedPairs.push({ pair1, pair2, intermediate });
                }
            }
        }
        
        return relatedPairs;
    }

    calculateQuantumLeverage(metrics) {
        // **LEVERAGE CU√ÅNTICO**: Sin l√≠mites determin√≠sticos
        let leverage = 1;
        
        // Factor 1: Volatilidad (m√°s volatilidad = m√°s leverage potencial)
        leverage += metrics.volatility * 2;
        
        // Factor 2: Liquidez (m√°s liquidez = m√°s leverage seguro)
        leverage += (metrics.liquidityScore / 100) * 10;
        
        // Factor 3: Potencial cu√°ntico
        leverage += (metrics.quantumPotential / 100) * 20;
        
        // Factor 4: Score de arbitraje
        leverage += (metrics.arbitrageScore / 100) * 15;
        
        // **SIN L√çMITES**: Leverage cu√°ntico m√°ximo
        return Math.min(leverage, this.marketMakerConfig.maxLeverageQuantum);
    }

    calculateProfitPotential(metrics) {
        // **PROFIT M√ÅXIMO**: Calcular potencial de ganancia
        let profitPotential = 0;
        
        // Factor 1: Spread (mayor spread = mayor profit potencial)
        profitPotential += metrics.spread * 100;
        
        // Factor 2: Volatilidad (mayor volatilidad = mayor profit)
        profitPotential += metrics.volatility * 10;
        
        // Factor 3: Volumen (mayor volumen = mayor profit sostenible)
        profitPotential += Math.min(metrics.volume24h / 1000000, 50);
        
        // Factor 4: Arbitraje potencial
        profitPotential += metrics.arbitrageScore;
        
        return Math.min(profitPotential, 1000); // Normalizar
    }

    calculateRiskAdjustedScore(metrics) {
        // **RISK-ADJUSTED PROFIT**: Maximizar profit ajustado por riesgo
        const profit = metrics.profitPotential;
        const risk = Math.max(metrics.volatility, 1);
        const liquidity = Math.max(metrics.liquidityScore, 1);
        
        return (profit / risk) * Math.log(liquidity);
    }

    async calculateQuantumCorrelationMatrices() {
        console.log('[QUANTUM MARKET MAKER] üîÆ Calculando matrices de correlaci√≥n cu√°ntica...');

        // Cap configurable para s√≠mbolos a correlacionar
        // Prioridad: QMM_CORR_SYMBOLS > QMM_MAX_ACTIVE_SYMBOLS > QUANTUM_MAX_SYMBOLS
        // Valor 0 = sin l√≠mite (usar todos)
        const rawCap =
            process.env.QMM_CORR_SYMBOLS ??
            process.env.QMM_MAX_ACTIVE_SYMBOLS ??
            process.env.QUANTUM_MAX_SYMBOLS ??
            '500';

        let cap = parseInt(String(rawCap), 10);
        if (!Number.isFinite(cap) || cap < 0) cap = 500;
        const unlimited = cap === 0;

        // **CORRELACI√ìN MULTIDIMENSIONAL**: Entre TODOS los s√≠mbolos
        let ranked = Array.from(this.symbolsMetrics.keys())
            .filter(symbol => {
                const metrics = this.symbolsMetrics.get(symbol);
                return metrics && metrics.price && metrics.volume24h > 100;
            })
            .sort((a, b) => {
                const scoreA = this.symbolsMetrics.get(a).riskAdjustedScore || 0;
                const scoreB = this.symbolsMetrics.get(b).riskAdjustedScore || 0;
                return scoreB - scoreA;
            });

        const activeSymbols = unlimited ? ranked : ranked.slice(0, cap);

        console.log(`[QUANTUM MARKET MAKER] üéØ Analizando correlaciones entre ${activeSymbols.length} s√≠mbolos (cap=${unlimited ? 'unlimited' : cap})`);

        // Calcular correlaciones por pares
        for (let i = 0; i < activeSymbols.length; i++) {
            for (let j = i + 1; j < activeSymbols.length; j++) {
                const symbol1 = activeSymbols[i];
                const symbol2 = activeSymbols[j];

                const correlation = await this.calculatePairCorrelation(symbol1, symbol2);

                if (Math.abs(correlation) > 0.7) { // Correlaci√≥n significativa
                    const key = `${symbol1}|${symbol2}`;
                    this.quantumCorrelationMatrix.set(key, {
                        correlation,
                        symbol1,
                        symbol2,
                        arbitrageOpportunity: Math.abs(correlation) > 0.9,
                        hedgeOpportunity: correlation < -0.7,
                        lastUpdate: Date.now()
                    });
                }
            }

            if (i % 50 === 0) {
                console.log(`[QUANTUM MARKET MAKER] ‚ö° Correlaciones procesadas: ${i}/${activeSymbols.length}`);
            }
        }

        console.log(`[QUANTUM MARKET MAKER] ‚úÖ ${this.quantumCorrelationMatrix.size} correlaciones cu√°nticas identificadas`);
    }

    async calculatePairCorrelation(symbol1, symbol2) {
        try {
            const metrics1 = this.symbolsMetrics.get(symbol1);
            const metrics2 = this.symbolsMetrics.get(symbol2);
            
            if (!metrics1 || !metrics2) return 0;
            
            // Correlaci√≥n simple basada en cambios de precio
            const change1 = metrics1.priceChange24h || 0;
            const change2 = metrics2.priceChange24h || 0;
            
            // Correlaci√≥n basada en patr√≥n de nombres y comportamiento
            let correlation = 0;
            
            // Mismo quote currency = alta correlaci√≥n
            const quote1 = this.extractQuoteCurrency(symbol1);
            const quote2 = this.extractQuoteCurrency(symbol2);
            if (quote1 === quote2) correlation += 0.3;
            
            // Misma categor√≠a = correlaci√≥n media
            const category1 = this.getSymbolCategory(symbol1);
            const category2 = this.getSymbolCategory(symbol2);
            if (category1 === category2) correlation += 0.2;
            
            // Cambios de precio similares = correlaci√≥n directa
            const priceSimilarity = 1 - Math.abs(change1 - change2) / 100;
            correlation += priceSimilarity * 0.5;
            
            return Math.max(-1, Math.min(1, correlation));
            
        } catch (error) {
            return 0;
        }
    }

    getSymbolCategory(symbol) {
        if (symbol.includes('BTC') || symbol.includes('ETH') || symbol.includes('BNB')) return 'major';
        if (symbol.includes('SHIB') || symbol.includes('DOGE') || symbol.includes('PEPE')) return 'meme';
        if (symbol.includes('1000') || symbol.includes('RATS') || symbol.includes('SATS')) return 'dark';
        return 'exotic';
    }

    async scanForArbitrageOpportunities() {
        console.log('[QUANTUM MARKET MAKER] üîç Escaneando oportunidades de arbitraje...');
        
        let opportunitiesFound = 0;
        
        // **ARBITRAJE TRIANGULAR**: Buscar en todas las correlaciones
        for (const [key, correlation] of this.quantumCorrelationMatrix) {
            if (correlation.arbitrageOpportunity) {
                const opportunity = await this.analyzeArbitrageOpportunity(correlation);
                
                if (opportunity.profitPotential > this.marketMakerConfig.minProfitThreshold) {
                    this.arbitrageOpportunities.set(key, opportunity);
                    opportunitiesFound++;
                }
            }
        }
        
        console.log(`[QUANTUM MARKET MAKER] üí∞ ${opportunitiesFound} oportunidades de arbitraje detectadas`);
        
        this.performanceMetrics.totalArbitrageExecuted = opportunitiesFound;
    }

    async analyzeArbitrageOpportunity(correlation) {
        const { symbol1, symbol2 } = correlation;
        
        const metrics1 = this.symbolsMetrics.get(symbol1);
        const metrics2 = this.symbolsMetrics.get(symbol2);
        
        // **INGENIER√çA INVERSA**: Calcular profit exacto
        const spreadDifference = Math.abs(metrics1.spread - metrics2.spread);
        const volatilityEdge = Math.abs(metrics1.volatility - metrics2.volatility);
        const liquidityEdge = Math.abs(metrics1.liquidityScore - metrics2.liquidityScore);
        
        const profitPotential = (spreadDifference + volatilityEdge + liquidityEdge) / 300;
        const leverageRecommended = Math.min(
            metrics1.quantumLeverage,
            metrics2.quantumLeverage
        );
        
        return {
            symbol1,
            symbol2,
            profitPotential,
            leverageRecommended,
            estimatedProfit: profitPotential * leverageRecommended * 100,
            executionTime: this.marketMakerConfig.quantumSpeedExecution,
            riskLevel: Math.max(metrics1.volatility, metrics2.volatility) / 100,
            priority: profitPotential * leverageRecommended,
            lastCalculated: Date.now()
        };
    }

    startQuantumMarketMaking() {
        console.log('[QUANTUM MARKET MAKER] üöÄ INICIANDO MARKET MAKING CU√ÅNTICO...');
        
        // **MOTOR PRINCIPAL**: Ejecuci√≥n continua sin l√≠mites
        setInterval(async () => {
            await this.executeQuantumMarketMaking();
        }, this.marketMakerConfig.quantumSpeedExecution);
        
        // **ACTUALIZACI√ìN DE M√âTRICAS**: Cada segundo
        setInterval(async () => {
            await this.updateRealTimeMetrics();
        }, 1000);
        
        // **REBALANCEO CU√ÅNTICO**: Cada 10 segundos
        setInterval(async () => {
            await this.rebalanceQuantumPositions();
        }, 10000);
        
        console.log('[QUANTUM MARKET MAKER] ‚ö° Motor cu√°ntico activado - Profit m√°ximo iniciado');
    }

    async executeQuantumMarketMaking() {
        try {
            // **MATRIZ NxN INFINITA**: Optimizaci√≥n secuencial z=9+16j, log7919, Œª=888
            const nxnResults = await this.nxnMatrix.optimizeSequential();
            
            // **PROFIT MAXIMIZER CU√ÅNTICO**: Ejecutar algoritmo de profit m√°ximo
            const profitResults = await this.profitMaximizer.maximizeQuantumProfits();
            
            // **EJECUCI√ìN PARALELA TRADICIONAL**: M√∫ltiples estrategias simult√°neas
            const promises = [
                this.executeArbitrageOpportunities(),
                this.executeMomentumStrategies(),
                this.executeMeanReversionStrategies(),
                this.executeVolatilityArbitrage(),
                this.executeCorrelationTrades()
            ];
            
            const traditionalResults = await Promise.allSettled(promises);
            
            // **M√âTRICAS COMBINADAS CON NxN**
            this.updateCombinedMetrics(profitResults, traditionalResults, nxnResults);
            
            console.log(`[QUANTUM MARKET MAKER] üåå Espacios infinitos: ${nxnResults.infiniteSpacesFound}`);
            console.log(`[QUANTUM MARKET MAKER] üîÆ Multiplicador m√°ximo: ${nxnResults.maxProfitMultiplier}x`);
            console.log(`[QUANTUM MARKET MAKER] üí∞ Profit NxN: ${nxnResults.totalProfitGenerated}`);
            console.log(`[QUANTUM MARKET MAKER] ‚ö° Streams activos: ${profitResults.activeProfitStreams}`);
            
        } catch (error) {
            console.error('[QUANTUM MARKET MAKER] Error en ejecuci√≥n cu√°ntica NxN:', error.message);
        }
    }

    updateCombinedMetrics(profitResults, traditionalResults, nxnResults) {
        // Combinar m√©tricas del profit maximizer con las tradicionales y NxN
        this.performanceMetrics.totalProfitGenerated += profitResults.totalProfitGenerated + (nxnResults?.totalProfitGenerated || 0);
        this.performanceMetrics.profitPerSecond = Math.max(profitResults.profitPerSecond, nxnResults?.averageConvergenceTime || 0);
        this.performanceMetrics.averageLeverageUsed = profitResults.leverageUtilization;
        this.performanceMetrics.quantumSuccessRate = profitResults.quantumEfficiency;
        this.performanceMetrics.maxSimultaneousPositions = Math.max(
            this.performanceMetrics.maxSimultaneousPositions,
            profitResults.activeProfitStreams
        );
        
        // **M√âTRICAS NxN ESPEC√çFICAS**
        this.performanceMetrics.infiniteSpacesDetected = nxnResults?.infiniteSpacesFound || 0;
        this.performanceMetrics.maxProfitMultiplier = nxnResults?.maxProfitMultiplier || 1.0;
        this.performanceMetrics.nxnCycles = nxnResults?.totalCycles || 0;
        this.performanceMetrics.convergenceAchieved = nxnResults?.convergenceAchieved || 0;
        this.performanceMetrics.matrixEfficiency = nxnResults?.matrixEfficiency || 0;
    }

    async executeArbitrageOpportunities() {
        const topOpportunities = Array.from(this.arbitrageOpportunities.values())
            .sort((a, b) => b.priority - a.priority)
            .slice(0, 10); // Top 10 oportunidades
        
        for (const opportunity of topOpportunities) {
            if (opportunity.profitPotential > this.marketMakerConfig.minProfitThreshold) {
                await this.executeArbitrageTrade(opportunity);
            }
        }
    }

    async executeArbitrageTrade(opportunity) {
        try {
            const { symbol1, symbol2, leverageRecommended, profitPotential } = opportunity;
            
            // **LEVERAGE CU√ÅNTICO DIN√ÅMICO**: Calcular leverage √≥ptimo para cada s√≠mbolo
            const metrics1 = this.symbolsMetrics.get(symbol1);
            const metrics2 = this.symbolsMetrics.get(symbol2);
            
            const systemState = this.getSystemState();
            const confluenceData = this.calculateConfluenceData(opportunity);
            
            const leverage1 = this.leverageEngine.calculateQuantumLeverage(symbol1, metrics1, systemState, confluenceData);
            const leverage2 = this.leverageEngine.calculateQuantumLeverage(symbol2, metrics2, systemState, confluenceData);
            
            // **ARBITRAJE CU√ÅNTICO AVANZADO**: Usar leverage diferenciado
            const optimalLeverage = Math.min(leverage1.recommendedLeverage, leverage2.recommendedLeverage);
            const tradeSize = this.calculateQuantumTradeSize(opportunity, optimalLeverage);
            
            // **ESTRATEGIA DE ARBITRAJE SOFISTICADA**
            const arbitrageStrategy = this.determineArbitrageStrategy(opportunity, leverage1, leverage2);
            
            console.log(`[QUANTUM ARBITRAGE] Ejecutando arbitraje cu√°ntico: ${symbol1}‚ü∑${symbol2}`);
            console.log(`[QUANTUM ARBITRAGE] Leverage: ${optimalLeverage}x, Estrategia: ${arbitrageStrategy}`);
            
            const results = await this.executeQuantumArbitrageStrategy(arbitrageStrategy, {
                symbol1, symbol2, 
                tradeSize, 
                leverage: optimalLeverage,
                metrics1, metrics2
            });
            
            if (results.success) {
                this.recordSuccessfulArbitrage(opportunity, results.trade1, results.trade2);
                this.performanceMetrics.totalProfitGenerated += profitPotential * optimalLeverage;
                this.performanceMetrics.averageLeverageUsed = (this.performanceMetrics.averageLeverageUsed + optimalLeverage) / 2;
            }
            
        } catch (error) {
            console.warn('[QUANTUM MARKET MAKER] Error ejecutando arbitraje cu√°ntico:', error.message);
        }
    }

    // **NUEVO**: Calcular datos de confluencia para leverage
    calculateConfluenceData(opportunity) {
        const { symbol1, symbol2, correlation } = opportunity;
        
        return {
            correlationStrength: Math.abs(correlation),
            arbitrageOpportunity: opportunity.profitPotential,
            lunarAlignment: this.calculateLunarAlignment(symbol1, symbol2),
            marketSentiment: this.calculateMarketSentiment(symbol1, symbol2),
            technicalConfluence: this.calculateTechnicalConfluence(symbol1, symbol2)
        };
    }

    // **NUEVO**: Obtener estado del sistema para leverage
    getSystemState() {
        // Esto se conectar√≠a con el sistema principal, por ahora valores de ejemplo
        return {
            consciousness: 0.85,  // Desde el sistema principal
            coherence: 0.92,      // Desde el sistema principal  
            big_bang_activated: false,
            zurita_multiplier: 1.0
        };
    }

    // **NUEVO**: Tama√±o de trade cu√°ntico con leverage
    calculateQuantumTradeSize(opportunity, leverage) {
        const { profitPotential, symbol1, symbol2 } = opportunity;
        
        // Tama√±o base m√°s agresivo con leverage
        const baseSize = 0.02; // 2% base
        const leverageMultiplier = Math.log(leverage + 1) / Math.log(10); // Escalado logar√≠tmico
        const profitMultiplier = profitPotential * 50; // Mayor multiplicador
        
        // Ajuste por liquidez de ambos s√≠mbolos
        const metrics1 = this.symbolsMetrics.get(symbol1);
        const metrics2 = this.symbolsMetrics.get(symbol2);
        const liquidityFactor = Math.min(
            (metrics1?.liquidityScore || 10) / 100,
            (metrics2?.liquidityScore || 10) / 100
        );
        
        return baseSize * leverageMultiplier * profitMultiplier * liquidityFactor;
    }

    // **NUEVO**: Determinar estrategia de arbitraje
    determineArbitrageStrategy(opportunity, leverage1, leverage2) {
        const avgLeverage = (leverage1.recommendedLeverage + leverage2.recommendedLeverage) / 2;
        const profitPotential = opportunity.profitPotential;
        
        if (avgLeverage >= 75 && profitPotential >= 0.01) {
            return 'AGGRESSIVE_SIMULTANEOUS'; // Ejecuci√≥n agresiva simult√°nea
        } else if (avgLeverage >= 50 && profitPotential >= 0.005) {
            return 'FAST_TRIANGULAR';        // Arbitraje triangular r√°pido
        } else if (avgLeverage >= 25 && profitPotential >= 0.002) {
            return 'SYSTEMATIC_SEQUENTIAL';  // Secuencial sistem√°tico
        } else if (avgLeverage >= 10) {
            return 'CONSERVATIVE_HEDGE';     // Hedge conservador
        } else {
            return 'MINIMAL_EXPOSURE';       // Exposici√≥n m√≠nima
        }
    }

    // **NUEVO**: Ejecutar estrategia de arbitraje cu√°ntica
    async executeQuantumArbitrageStrategy(strategy, params) {
        const { symbol1, symbol2, tradeSize, leverage, metrics1, metrics2 } = params;
        
        switch (strategy) {
            case 'AGGRESSIVE_SIMULTANEOUS':
                return await this.executeAggressiveSimultaneous(params);
                
            case 'FAST_TRIANGULAR':
                return await this.executeFastTriangular(params);
                
            case 'SYSTEMATIC_SEQUENTIAL':
                return await this.executeSystematicSequential(params);
                
            case 'CONSERVATIVE_HEDGE':
                return await this.executeConservativeHedge(params);
                
            case 'MINIMAL_EXPOSURE':
                return await this.executeMinimalExposure(params);
                
            default:
                return await this.executeMinimalExposure(params);
        }
    }

    // **ESTRATEGIA 1**: Ejecuci√≥n agresiva simult√°nea
    async executeAggressiveSimultaneous(params) {
        const { symbol1, symbol2, tradeSize, leverage } = params;
        
        try {
            // **M√ÅXIMO LEVERAGE**: Ejecuci√≥n simult√°nea con leverage alto
            const adjustedSize1 = tradeSize * leverage * 0.8;
            const adjustedSize2 = tradeSize * leverage * 0.8;
            
            const [trade1, trade2] = await Promise.all([
                this.binanceConnector.executeRealOrder({
                    symbol: symbol1,
                    side: 'BUY',
                    quantity: adjustedSize1,
                    type: 'MARKET'
                }),
                this.binanceConnector.executeRealOrder({
                    symbol: symbol2,
                    side: 'SELL',
                    quantity: adjustedSize2,
                    type: 'MARKET'
                })
            ]);
            
            return { success: true, trade1, trade2, strategy: 'AGGRESSIVE_SIMULTANEOUS' };
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en estrategia agresiva:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **ESTRATEGIA 2**: Arbitraje triangular r√°pido
    async executeFastTriangular(params) {
        const { symbol1, symbol2, tradeSize, leverage } = params;
        
        try {
            // **ARBITRAJE TRIANGULAR**: Buscar tercer par para maximizar profit
            const intermediatePair = this.findOptimalIntermediatePair(symbol1, symbol2);
            
            if (intermediatePair) {
                // Ejecutar arbitraje triangular de 3 pasos
                const results = await this.executeTriangularArbitrage(symbol1, symbol2, intermediatePair, tradeSize * leverage);
                return { success: results.success, ...results, strategy: 'FAST_TRIANGULAR' };
            } else {
                // Fallback a ejecuci√≥n directa
                return await this.executeAggressiveSimultaneous(params);
            }
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en arbitraje triangular:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **ESTRATEGIA 3**: Secuencial sistem√°tico
    async executeSystematicSequential(params) {
        const { symbol1, symbol2, tradeSize, leverage } = params;
        
        try {
            // Ejecuci√≥n secuencial con rebalanceo
            const trade1 = await this.binanceConnector.executeRealOrder({
                symbol: symbol1,
                side: 'BUY',
                quantity: tradeSize * leverage * 0.6,
                type: 'MARKET'
            });
            
            // Esperar confirmaci√≥n y ejecutar segundo trade
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const trade2 = await this.binanceConnector.executeRealOrder({
                symbol: symbol2,
                side: 'SELL',
                quantity: tradeSize * leverage * 0.6,
                type: 'MARKET'
            });
            
            return { success: true, trade1, trade2, strategy: 'SYSTEMATIC_SEQUENTIAL' };
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en secuencial sistem√°tico:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **ESTRATEGIA 4**: Hedge conservador
    async executeConservativeHedge(params) {
        const { symbol1, symbol2, tradeSize } = params;
        
        try {
            // Ejecuci√≥n conservadora con hedge
            const conservativeSize = tradeSize * 0.5;
            
            const trade1 = await this.binanceConnector.executeRealOrder({
                symbol: symbol1,
                side: 'BUY',
                quantity: conservativeSize,
                type: 'LIMIT' // Usar LIMIT para mejor precio
            });
            
            const trade2 = await this.binanceConnector.executeRealOrder({
                symbol: symbol2,
                side: 'SELL',
                quantity: conservativeSize,
                type: 'LIMIT'
            });
            
            return { success: true, trade1, trade2, strategy: 'CONSERVATIVE_HEDGE' };
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en hedge conservador:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **ESTRATEGIA 5**: Exposici√≥n m√≠nima
    async executeMinimalExposure(params) {
        const { symbol1, tradeSize } = params;
        
        try {
            // Solo una peque√±a posici√≥n de prueba
            const minimalSize = tradeSize * 0.1;
            
            const trade1 = await this.binanceConnector.executeRealOrder({
                symbol: symbol1,
                side: 'BUY',
                quantity: minimalSize,
                type: 'MARKET'
            });
            
            return { success: true, trade1, trade2: null, strategy: 'MINIMAL_EXPOSURE' };
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en exposici√≥n m√≠nima:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **AUXILIAR**: Encontrar par intermedio √≥ptimo
    findOptimalIntermediatePair(symbol1, symbol2) {
        const base1 = this.extractBaseCurrency(symbol1);
        const base2 = this.extractBaseCurrency(symbol2);
        const quote1 = this.extractQuoteCurrency(symbol1);
        const quote2 = this.extractQuoteCurrency(symbol2);
        
        // Buscar pares intermedios comunes
        const commonIntermediate = ['BTC', 'ETH', 'BNB', 'USDT'];
        
        for (const intermediate of commonIntermediate) {
            if (intermediate !== base1 && intermediate !== base2 && 
                intermediate !== quote1 && intermediate !== quote2) {
                
                const intermediatePair1 = `${base1}${intermediate}`;
                const intermediatePair2 = `${intermediate}${base2}`;
                
                if (this.allBinanceSymbols.has(intermediatePair1) && 
                    this.allBinanceSymbols.has(intermediatePair2)) {
                    return { pair1: intermediatePair1, pair2: intermediatePair2, intermediate };
                }
            }
        }
        
        return null;
    }

    // **AUXILIAR**: Ejecutar arbitraje triangular
    async executeTriangularArbitrage(symbol1, symbol2, intermediatePair, totalSize) {
        try {
            const { pair1, pair2, intermediate } = intermediatePair;
            const sizePerLeg = totalSize / 3;
            
            // Ejecutar 3 trades simult√°neos para arbitraje triangular
            const [trade1, trade2, trade3] = await Promise.all([
                this.binanceConnector.executeRealOrder({
                    symbol: symbol1,
                    side: 'BUY',
                    quantity: sizePerLeg,
                    type: 'MARKET'
                }),
                this.binanceConnector.executeRealOrder({
                    symbol: pair1,
                    side: 'SELL',
                    quantity: sizePerLeg,
                    type: 'MARKET'
                }),
                this.binanceConnector.executeRealOrder({
                    symbol: pair2,
                    side: 'BUY',
                    quantity: sizePerLeg,
                    type: 'MARKET'
                })
            ]);
            
            return { 
                success: true, 
                trade1, 
                trade2: trade2, 
                trade3, 
                triangularPairs: [symbol1, pair1, pair2] 
            };
            
        } catch (error) {
            console.error('[QUANTUM ARBITRAGE] Error en triangular:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **AUXILIARES**: C√°lculos de confluencia
    calculateLunarAlignment(symbol1, symbol2) {
        // Obtener influencia lunar de ambos s√≠mbolos
        const lunar1 = this.binanceConnector.lunarInfluence.get(symbol1);
        const lunar2 = this.binanceConnector.lunarInfluence.get(symbol2);
        
        if (!lunar1 || !lunar2) return 0.5;
        
        // Calcular alineaci√≥n basada en fases lunares y cuadrantes
        const phaseAlignment = lunar1.moonPhase === lunar2.moonPhase ? 1.0 : 0.5;
        const quadrantSynergy = this.calculateQuadrantSynergy(lunar1.quadrant, lunar2.quadrant);
        
        return (phaseAlignment + quadrantSynergy) / 2;
    }

    calculateQuadrantSynergy(quadrant1, quadrant2) {
        // Sinergia entre cuadrantes lunares
        const synergyMatrix = {
            'ACCUMULATION_QUADRANT': { 'GROWTH_QUADRANT': 0.9, 'MOMENTUM_QUADRANT': 0.8 },
            'CHAOS_QUADRANT': { 'MAXIMUM_IRRATIONALITY_QUADRANT': 1.0, 'EXOTIC_MADNESS_QUADRANT': 0.95 },
            'VIRAL_BIRTH_QUADRANT': { 'MEME_EXPLOSION_QUADRANT': 1.0, 'PEAK_MEME_QUADRANT': 0.9 }
        };
        
        return synergyMatrix[quadrant1]?.[quadrant2] || 0.5;
    }

    calculateMarketSentiment(symbol1, symbol2) {
        const metrics1 = this.symbolsMetrics.get(symbol1);
        const metrics2 = this.symbolsMetrics.get(symbol2);
        
        if (!metrics1 || !metrics2) return 0.5;
        
        // Sentiment basado en cambios de precio y volumen
        const sentiment1 = metrics1.priceChange24h > 0 ? 0.7 : 0.3;
        const sentiment2 = metrics2.priceChange24h > 0 ? 0.7 : 0.3;
        
        return (sentiment1 + sentiment2) / 2;
    }

    calculateTechnicalConfluence(symbol1, symbol2) {
        const metrics1 = this.symbolsMetrics.get(symbol1);
        const metrics2 = this.symbolsMetrics.get(symbol2);
        
        if (!metrics1 || !metrics2) return 0.5;
        
        // Confluencia t√©cnica basada en volatilidad y spread
        const volatilityDiff = Math.abs(metrics1.volatility - metrics2.volatility);
        const spreadDiff = Math.abs(metrics1.spread - metrics2.spread);
        
        const volatilityConfluence = 1 - Math.min(volatilityDiff * 10, 1);
        const spreadConfluence = 1 - Math.min(spreadDiff * 100, 1);
        
        return (volatilityConfluence + spreadConfluence) / 2;
    }

    calculateOptimalTradeSize(opportunity) {
        // **TAMA√ëO √ìPTIMO**: Basado en edge cu√°ntico y leverage
        const { leverageRecommended, profitPotential } = opportunity;
        
        // Usar porcentaje del capital disponible
        const baseSize = 0.01; // 1% base
        const leverageMultiplier = leverageRecommended / 10;
        const profitMultiplier = profitPotential * 100;
        
        return baseSize * leverageMultiplier * profitMultiplier;
    }

    recordSuccessfulArbitrage(opportunity, result1, result2) {
        const record = {
            timestamp: Date.now(),
            opportunity,
            execution: { result1, result2 },
            profit: opportunity.estimatedProfit
        };
        
        this.profitStreams.set(Date.now().toString(), record);
        this.performanceMetrics.totalArbitrageExecuted++;
    }

    async executeMomentumStrategies() {
        // **MOMENTUM CU√ÅNTICO**: Aprovechar tendencias fuertes
        const momentumSymbols = Array.from(this.symbolsMetrics.entries())
            .filter(([symbol, metrics]) => {
                return Math.abs(metrics.priceChange24h || 0) > 5 && metrics.volume24h > 1000000;
            })
            .sort((a, b) => Math.abs(b[1].priceChange24h) - Math.abs(a[1].priceChange24h))
            .slice(0, 20);
        
        for (const [symbol, metrics] of momentumSymbols) {
            await this.executeMomentumTrade(symbol, metrics);
        }
    }

    async executeMomentumTrade(symbol, metrics) {
        try {
            const direction = metrics.priceChange24h > 0 ? 'BUY' : 'SELL';
            const leverage = metrics.quantumLeverage;
            const size = this.calculateMomentumSize(metrics);
            
            if (size > 0) {
                // Publicar se√±al en lugar de ejecutar orden directamente
                try {
                    const SignalBus = require('../leonardo-consciousness/SignalBus');
                    SignalBus.publish({
                        symbol,
                        direction: direction === 'BUY' ? 'LONG' : 'SHORT',
                        potentialProfit: Math.abs(metrics.priceChange24h),
                        confidence: Math.min(1, Math.abs(metrics.priceChange24h)/10),
                        compositeScore: Math.min(1, Math.abs(metrics.priceChange24h)/10)
                    }, 'QuantumMarketMaker');
                } catch (_) {}
                this.recordMomentumTrade(symbol, direction, size, leverage);
            }
            
        } catch (error) {
            console.warn('[QUANTUM MARKET MAKER] Error momentum:', error.message);
        }
    }

    calculateMomentumSize(metrics) {
        const momentumStrength = Math.abs(metrics.priceChange24h) / 100;
        const liquidityFactor = Math.min(metrics.liquidityScore / 100, 1);
        const baseSize = 0.005; // 0.5% base
        
        return baseSize * momentumStrength * liquidityFactor * metrics.quantumLeverage;
    }

    recordMomentumTrade(symbol, direction, size, leverage) {
        const profit = size * leverage * 0.01; // Estimado 1% profit
        this.performanceMetrics.totalProfitGenerated += profit;
    }

    async executeMeanReversionStrategies() {
        // **MEAN REVERSION CU√ÅNTICO**: Aprovechar reversiones extremas
        // Implementaci√≥n similar a momentum pero en direcci√≥n contraria para extremos
    }

    async executeVolatilityArbitrage() {
        // **ARBITRAJE DE VOLATILIDAD**: Explotar diferencias de volatilidad
        // Entre s√≠mbolos correlacionados
    }

    async executeCorrelationTrades() {
        // **TRADES DE CORRELACI√ìN**: Explotar correlaciones temporales
        // Entre s√≠mbolos de la matriz cu√°ntica
    }

    async updateRealTimeMetrics() {
        // Actualizar m√©tricas de rendimiento en tiempo real
        this.performanceMetrics.totalSymbolsExploited = this.quantumPositions.size;
        this.performanceMetrics.maxSimultaneousPositions = Math.max(
            this.performanceMetrics.maxSimultaneousPositions,
            this.quantumPositions.size
        );
        
        // Calcular profit por segundo
        const profitPerSecond = this.performanceMetrics.totalProfitGenerated / (Date.now() / 1000);
        this.performanceMetrics.profitPerSecond = profitPerSecond;
    }

    async rebalanceQuantumPositions() {
        // **REBALANCEO CU√ÅNTICO**: Optimizar posiciones activas
        console.log(`[QUANTUM MARKET MAKER] üîÑ Rebalanceando ${this.quantumPositions.size} posiciones cu√°nticas`);
    }

    // **API PARA M√âTRICAS EN TIEMPO REAL**
    getPerformanceReport() {
        return {
            ...this.performanceMetrics,
            activeSymbols: this.allBinanceSymbols.size,
            arbitrageOpportunities: this.arbitrageOpportunities.size,
            correlationPairs: this.quantumCorrelationMatrix.size,
            profitStreams: this.profitStreams.size,
            timestamp: new Date().toISOString()
        };
    }

    getTopPerformingSymbols(count = 50) {
        return Array.from(this.symbolsMetrics.entries())
            .sort((a, b) => (b[1].riskAdjustedScore || 0) - (a[1].riskAdjustedScore || 0))
            .slice(0, count)
            .map(([symbol, metrics]) => ({
                symbol,
                score: metrics.riskAdjustedScore,
                leverage: metrics.quantumLeverage,
                profit: metrics.profitPotential
            }));
    }

    // **APIS DEL PROFIT MAXIMIZER**
    getProfitMaximizerReport() {
        return this.profitMaximizer.getMaximizerReport();
    }

    getTopProfitOpportunities(count = 20) {
        return this.profitMaximizer.getTopProfitOpportunities(count);
    }

    async emergencyStopAll() {
        return await this.profitMaximizer.emergencyStopAndLiquidate();
    }

    getLeverageStats() {
        return this.leverageEngine.getSystemLeverageStats();
    }

    getTopLeverageOpportunities(count = 20) {
        return this.leverageEngine.getTopLeverageOpportunities(count);
    }

    // **VALIDACI√ìN MCP DE HIP√ìTESIS NxN**
    async validateNxNHypothesis() {
        return await this.nxnMatrix.validateHypothesis();
    }

    // **RESULTADOS DE OPTIMIZACI√ìN NxN**
    getNxNOptimizationResults() {
        return this.nxnMatrix.getOptimizationResults();
    }

    // **SCAN DE OPORTUNIDADES POR S√çMBOLO INDIVIDUAL**
    async scanSymbolOpportunities(symbol) {
        try {
            // Asegurar que tenemos m√©tricas para este s√≠mbolo
            let metrics = this.symbolsMetrics.get(symbol);
            
            // Si no tenemos m√©tricas, intentar obtenerlas primero
            if (!metrics) {
                console.log(`[MARKET MAKER] Inicializando m√©tricas para nuevo s√≠mbolo: ${symbol}`);
                await this.initializeSymbolMetrics(symbol);
                metrics = this.symbolsMetrics.get(symbol);
                
                // Si a√∫n no tenemos m√©tricas, no podemos continuar
                if (!metrics) {
                    console.warn(`[MARKET MAKER] No se pudieron obtener m√©tricas para ${symbol}`);
                    return [];
                }
            }
            
            const opportunities = [];
            
            // **1. ARBITRAJE DIRECTO**
            const arbitrageEdge = this.calculateArbitrageEdge(symbol, metrics);
            if (arbitrageEdge > this.marketMakerConfig.edgeDetectionThreshold) {
                opportunities.push({
                    type: 'ARBITRAGE',
                    symbol,
                    edge: arbitrageEdge,
                    profitPotential: arbitrageEdge * 1000,
                    executionSpeed: 'INSTANT',
                    leverageRecommendation: Math.min(arbitrageEdge * 10000, 50),
                    direction: 'NEUTRAL'
                });
            }
            
            // **2. MOMENTUM EXTREMO**
            const momentumEdge = this.calculateMomentumEdge(symbol, metrics);
            if (momentumEdge > 0.02) { // 2% m√≠nimo
                const direction = (metrics.priceChange24h || 0) > 0 ? 'BUY' : 'SELL';
                opportunities.push({
                    type: 'MOMENTUM',
                    symbol,
                    edge: momentumEdge,
                    profitPotential: momentumEdge * 500,
                    executionSpeed: 'FAST',
                    leverageRecommendation: Math.min(momentumEdge * 2000, 75),
                    direction
                });
            }
            
            // **3. VOLATILIDAD EXTREMA**
            const volatilityEdge = this.calculateVolatilityEdge(symbol, metrics);
            if (volatilityEdge > 0.05) { // 5% volatilidad m√≠nima
                opportunities.push({
                    type: 'VOLATILITY',
                    symbol,
                    edge: volatilityEdge,
                    profitPotential: volatilityEdge * 300,
                    executionSpeed: 'MEDIUM',
                    leverageRecommendation: Math.min(volatilityEdge * 500, 100),
                    direction: 'BIDIRECTIONAL'
                });
            }
            
            // **4. MEAN REVERSION EXTREMA**
            const reversionEdge = this.calculateMeanReversionEdge(symbol, metrics);
            if (reversionEdge > 0.03) { // 3% desviaci√≥n m√≠nima
                const direction = (metrics.priceChange24h || 0) > 0 ? 'SELL' : 'BUY'; // Opuesto al movimiento
                opportunities.push({
                    type: 'MEAN_REVERSION',
                    symbol,
                    edge: reversionEdge,
                    profitPotential: reversionEdge * 300,
                    executionSpeed: 'MEDIUM',
                    leverageRecommendation: Math.min(reversionEdge * 800, 50),
                    direction
                });
            }
            
            // **5. BREAKOUT PATTERN**
            const breakoutEdge = this.calculateBreakoutEdge(symbol, metrics);
            if (breakoutEdge > 0.02) {
                const direction = (metrics.priceChange24h || 0) > 0 ? 'BUY' : 'SELL'; // Seguir la direcci√≥n
                opportunities.push({
                    type: 'BREAKOUT',
                    symbol,
                    edge: breakoutEdge,
                    profitPotential: breakoutEdge * 800,
                    executionSpeed: 'FAST',
                    leverageRecommendation: Math.min(breakoutEdge * 1500, 125),
                    direction
                });
            }
            
            // **6. NUEVO: FUNDING RATE HARVEST** (para futuros)
            const fundingEdge = await this.calculateFundingRateEdge(symbol);
            if (Math.abs(fundingEdge) > 0.0001) { // 0.01% m√≠nimo
                const direction = fundingEdge < 0 ? 'BUY' : 'SELL'; // Negativo = long, Positivo = short
                opportunities.push({
                    type: 'FUNDING_HARVEST',
                    symbol,
                    edge: Math.abs(fundingEdge),
                    profitPotential: Math.abs(fundingEdge) * 2000,
                    executionSpeed: 'SLOW',
                    leverageRecommendation: 20, // Leverage moderado para funding
                    direction,
                    fundingRate: fundingEdge
                });
            }
            
            // Ordenar por potencial de beneficio
            return opportunities.sort((a, b) => b.profitPotential - a.profitPotential);
            
        } catch (error) {
            console.warn(`[MARKET MAKER] Error escaneando ${symbol}:`, error.message);
            return [];
        }
    }
    
    // Nuevo m√©todo para calcular el edge basado en funding rate
    async calculateFundingRateEdge(symbol) {
        try {
            // Obtener funding rate actual de Binance
            const endpoint = '/fapi/v1/premiumIndex';
            const params = { symbol };
            
            const data = await this.binanceConnector.makeRequest('GET', endpoint, params);
            
            if (data && data.lastFundingRate) {
                return parseFloat(data.lastFundingRate);
            }
            
            return 0;
        } catch (error) {
            // Silencioso para s√≠mbolos que no responden
            return 0;
        }
    }
    
    // **ESPACIOS INFINITOS DETECTADOS**
    getInfiniteSpaces() {
        return {
            totalDetected: this.performanceMetrics.infiniteSpacesDetected || 0,
            maxMultiplier: this.performanceMetrics.maxProfitMultiplier || 1.0,
            cycles: this.performanceMetrics.nxnCycles || 0,
            convergence: this.performanceMetrics.convergenceAchieved || 0,
            efficiency: this.performanceMetrics.matrixEfficiency || 0,
            parameters: {
                z: { real: 9, imaginary: 16 },
                log7919: Math.log(7919),
                lambda: 888
            }
        };
    }

    // **M√âTODOS DE INTERFACE UNIFICADA** - Requeridos por el sistema principal
    getAllSymbols() {
        return Array.from(this.allBinanceSymbols);
    }
    
    getSymbolsCount() {
        return this.allBinanceSymbols.size;
    }
    
    getActiveSymbols() {
        return Array.from(this.symbolsMetrics.keys())
            .filter(symbol => {
                const metrics = this.symbolsMetrics.get(symbol);
                return metrics && metrics.isActive;
            });
    }
    
    getAllOpportunities() {
        return Array.from(this.arbitrageOpportunities.values());
    }
    
    getSystemStatus() {
        return {
            totalSymbols: this.allBinanceSymbols.size,
            activeSymbols: this.getActiveSymbols().length,
            opportunities: this.arbitrageOpportunities.size,
            correlations: this.quantumCorrelationMatrix.size,
            profitStreams: this.profitStreams.size,
            performance: this.getPerformanceReport(),
            isInitialized: this.allBinanceSymbols.size > 0,
            lastUpdate: new Date().toISOString()
        };
    }

    // **ALGORITMO DE PROFIT M√ÅXIMO CON INGENIER√çA INVERSA**
    async executeMaximumProfitAlgorithm() {
        console.log('[QUANTUM PROFIT] üöÄ Iniciando algoritmo de profit m√°ximo...');
        
        try {
            // **PASO 1**: Identificar oportunidades de m√°ximo profit
            const maxProfitOpportunities = await this.identifyMaxProfitOpportunities();
            
            // **PASO 2**: Aplicar ingenier√≠a inversa para optimizaci√≥n
            const optimizedStrategies = this.applyReverseEngineering(maxProfitOpportunities);
            
            // **PASO 3**: Ejecutar estrategias paralelas sin l√≠mites
            const executionResults = await this.executeParallelMaxProfitStrategies(optimizedStrategies);
            
            // **PASO 4**: Reinvertir profits para crecimiento exponencial
            await this.reinvestProfitsForExponentialGrowth(executionResults);
            
            console.log('[QUANTUM PROFIT] ‚úÖ Algoritmo de profit m√°ximo completado');
            return executionResults;
            
        } catch (error) {
            console.error('[QUANTUM PROFIT] Error en algoritmo de profit m√°ximo:', error.message);
            return { success: false, error: error.message };
        }
    }

    // **IDENTIFICAR OPORTUNIDADES DE M√ÅXIMO PROFIT**
    async identifyMaxProfitOpportunities() {
        console.log('[QUANTUM PROFIT] üîç Identificando oportunidades de profit m√°ximo...');
        
        const opportunities = [];
        
        // **Oportunidad 1**: Leverage extremo en s√≠mbolos de alta confluencia
        const extremeLeverageOpportunities = this.findExtremeLeverageOpportunities();
        opportunities.push(...extremeLeverageOpportunities);
        
        // **Oportunidad 2**: Arbitraje triangular multi-par
        const triangularOpportunities = await this.findTriangularArbitrageChains();
        opportunities.push(...triangularOpportunities);
        
        // **Oportunidad 3**: Momentum extremo + volatilidad
        const momentumVolatilityOpportunities = this.findMomentumVolatilityOpportunities();
        opportunities.push(...momentumVolatilityOpportunities);
        
        // **Oportunidad 4**: Correlaci√≥n negativa para hedging profitable
        const hedgingOpportunities = this.findProfitableHedgingOpportunities();
        opportunities.push(...hedgingOpportunities);
        
        // **Oportunidad 5**: Lado oscuro con multiplicador lunar
        const darkSideLunarOpportunities = this.findDarkSideLunarOpportunities();
        opportunities.push(...darkSideLunarOpportunities);
        
        // **Rankear por profit potencial**
        return opportunities
            .sort((a, b) => b.maxProfitPotential - a.maxProfitPotential)
            .slice(0, 20); // Top 20 oportunidades
    }

    findExtremeLeverageOpportunities() {
        const opportunities = [];
        
        for (const [symbol, metrics] of this.symbolsMetrics.entries()) {
            if (metrics.quantumLeverage >= 75 && metrics.riskAdjustedScore >= 80) {
                
                // Calcular leverage cu√°ntico con sistema actual
                const systemState = this.getSystemState();
                const confluenceData = { correlationStrength: 0.9, arbitrageOpportunity: 0.8 };
                
                const leverageResult = this.leverageEngine.calculateQuantumLeverage(
                    symbol, metrics, systemState, confluenceData
                );
                
                if (leverageResult.recommendedLeverage >= 50) {
                    opportunities.push({
                        type: 'EXTREME_LEVERAGE',
                        symbol,
                        leverage: leverageResult.recommendedLeverage,
                        maxProfitPotential: leverageResult.maxProfitPotential,
                        confidence: leverageResult.confidence,
                        strategy: 'MAXIMUM_LEVERAGE_EXPLOIT',
                        riskLevel: leverageResult.riskLevel,
                        executionPriority: leverageResult.maxProfitPotential * leverageResult.confidence
                    });
                }
            }
        }
        
        return opportunities;
    }

    async findTriangularArbitrageChains() {
        const opportunities = [];
        const processedTriangles = new Set();
        
        // Buscar cadenas triangulares en los top s√≠mbolos
        const topSymbols = Array.from(this.symbolsMetrics.keys()).slice(0, 100);
        
        for (let i = 0; i < topSymbols.length; i++) {
            for (let j = i + 1; j < topSymbols.length; j++) {
                const symbol1 = topSymbols[i];
                const symbol2 = topSymbols[j];
                
                const intermediatePair = this.findOptimalIntermediatePair(symbol1, symbol2);
                if (intermediatePair) {
                    const triangleKey = [symbol1, symbol2, intermediatePair.intermediate].sort().join('|');
                    
                    if (!processedTriangles.has(triangleKey)) {
                        processedTriangles.add(triangleKey);
                        
                        const profitPotential = await this.calculateTriangularProfitPotential(
                            symbol1, symbol2, intermediatePair
                        );
                        
                        if (profitPotential > 0.005) { // 0.5% m√≠nimo
                            opportunities.push({
                                type: 'TRIANGULAR_ARBITRAGE',
                                symbols: [symbol1, symbol2, intermediatePair.intermediate],
                                intermediatePair,
                                maxProfitPotential: profitPotential * 1000, // Escalar para comparaci√≥n
                                confidence: 0.8,
                                strategy: 'TRIANGULAR_CHAIN_EXECUTION',
                                riskLevel: 'MODERATE_EDGE',
                                executionPriority: profitPotential * 800
                            });
                        }
                    }
                }
            }
        }
        
        return opportunities;
    }

    async calculateTriangularProfitPotential(symbol1, symbol2, intermediatePair) {
        try {
            // Obtener precios actuales para c√°lculo te√≥rico
            const price1 = this.symbolsMetrics.get(symbol1)?.price || 0;
            const price2 = this.symbolsMetrics.get(symbol2)?.price || 0;
            const priceIntermediate1 = this.symbolsMetrics.get(intermediatePair.pair1)?.price || 0;
            const priceIntermediate2 = this.symbolsMetrics.get(intermediatePair.pair2)?.price || 0;
            
            if (price1 && price2 && priceIntermediate1 && priceIntermediate2) {
                // C√°lculo simplificado de profit triangular
                const theoreticalPrice = (priceIntermediate1 * priceIntermediate2);
                const actualPrice = price1 * price2;
                const spread = Math.abs(theoreticalPrice - actualPrice) / actualPrice;
                
                return Math.max(0, spread - 0.002); // Descontar fees
            }
            
            return 0;
            
        } catch (error) {
            return 0;
        }
    }

    findMomentumVolatilityOpportunities() {
        const opportunities = [];
        
        for (const [symbol, metrics] of this.symbolsMetrics.entries()) {
            const momentum = Math.abs(metrics.priceChange24h || 0);
            const volatility = metrics.volatility || 0;
            
            // Buscar momentum extremo + alta volatilidad
            if (momentum >= 15 && volatility >= 0.08) {
                const momentumVolatilityScore = momentum * volatility * 100;
                
                // Determinar leverage √≥ptimo para momentum
                const optimalLeverage = Math.min(momentum * 3, 100);
                
                opportunities.push({
                    type: 'MOMENTUM_VOLATILITY',
                    symbol,
                    momentum,
                    volatility,
                    leverage: optimalLeverage,
                    maxProfitPotential: momentumVolatilityScore * optimalLeverage,
                    confidence: Math.min(momentum / 20, 1.0),
                    strategy: 'MOMENTUM_VOLATILITY_EXPLOIT',
                    riskLevel: volatility > 0.15 ? 'EXTREME_EDGE' : 'HIGH_EDGE',
                    executionPriority: momentumVolatilityScore * optimalLeverage * 0.8
                });
            }
        }
        
        return opportunities;
    }

    findProfitableHedgingOpportunities() {
        const opportunities = [];
        
        // Buscar pares con correlaci√≥n negativa fuerte
        for (const [key, correlation] of this.quantumCorrelationMatrix.entries()) {
            if (correlation.correlation < -0.7) { // Correlaci√≥n negativa fuerte
                const { symbol1, symbol2 } = correlation;
                
                const metrics1 = this.symbolsMetrics.get(symbol1);
                const metrics2 = this.symbolsMetrics.get(symbol2);
                
                if (metrics1 && metrics2) {
                    const hedgingProfitPotential = this.calculateHedgingProfit(metrics1, metrics2, correlation.correlation);
                    
                    opportunities.push({
                        type: 'PROFITABLE_HEDGING',
                        symbols: [symbol1, symbol2],
                        correlation: correlation.correlation,
                        maxProfitPotential: hedgingProfitPotential,
                        confidence: Math.abs(correlation.correlation),
                        strategy: 'NEGATIVE_CORRELATION_HEDGE',
                        riskLevel: 'LOW_RISK',
                        executionPriority: hedgingProfitPotential * Math.abs(correlation.correlation)
                    });
                }
            }
        }
        
        return opportunities;
    }

    calculateHedgingProfit(metrics1, metrics2, correlation) {
        // Profit de hedging basado en volatilidad diferencial
        const volatilityDiff = Math.abs(metrics1.volatility - metrics2.volatility);
        const avgVolatility = (metrics1.volatility + metrics2.volatility) / 2;
        
        // Mayor diferencia de volatilidad = mayor profit potencial
        const hedgingEdge = volatilityDiff * avgVolatility * Math.abs(correlation) * 1000;
        
        return hedgingEdge;
    }

    findDarkSideLunarOpportunities() {
        const opportunities = [];
        
        // Obtener fase lunar actual
        const currentMoonPhase = this.binanceConnector.calculateMoonPhase(new Date());
        
        // Durante ciertas fases lunares, el lado oscuro tiene multiplicadores extremos
        const lunarMultipliers = {
            'full_moon': 3.0,
            'new_moon': 2.5,
            'waxing_gibbous': 2.0
        };
        
        const lunarMultiplier = lunarMultipliers[currentMoonPhase] || 1.0;
        
        if (lunarMultiplier >= 2.0) {
            // Buscar s√≠mbolos del lado oscuro con alta influencia lunar
            for (const symbol of this.binanceConnector.assetCategories.darkSide || []) {
                const metrics = this.symbolsMetrics.get(symbol);
                const lunarInfluence = this.binanceConnector.lunarInfluence.get(symbol);
                
                if (metrics && lunarInfluence && lunarInfluence.influence >= 0.8) {
                    const darkSideProfitPotential = metrics.profitPotential * lunarMultiplier * lunarInfluence.influence * 100;
                    
                    opportunities.push({
                        type: 'DARK_SIDE_LUNAR',
                        symbol,
                        moonPhase: currentMoonPhase,
                        lunarMultiplier,
                        lunarInfluence: lunarInfluence.influence,
                        maxProfitPotential: darkSideProfitPotential,
                        confidence: lunarInfluence.influence,
                        strategy: 'LUNAR_DARK_SIDE_EXPLOITATION',
                        riskLevel: 'EXTREME_EDGE',
                        executionPriority: darkSideProfitPotential * 1.2
                    });
                }
            }
        }
        
        return opportunities;
    }

    // **INGENIER√çA INVERSA PARA OPTIMIZACI√ìN**
    applyReverseEngineering(opportunities) {
        console.log('[QUANTUM PROFIT] üîß Aplicando ingenier√≠a inversa para optimizaci√≥n...');
        
        return opportunities.map(opportunity => {
            // **Ingenier√≠a Inversa**: Calcular par√°metros √≥ptimos trabajando hacia atr√°s desde el profit objetivo
            const targetProfit = opportunity.maxProfitPotential;
            const reverseEngineeredParams = this.reverseEngineerOptimalParams(opportunity, targetProfit);
            
            return {
                ...opportunity,
                ...reverseEngineeredParams,
                originalParams: { ...opportunity },
                optimizationApplied: true
            };
        });
    }

    reverseEngineerOptimalParams(opportunity, targetProfit) {
        // **INGENIER√çA INVERSA**: Calcular hacia atr√°s desde profit objetivo
        
        const optimalParams = {};
        
        // **Reverse Engineer Leverage**: ¬øQu√© leverage necesito para el profit objetivo?
        if (opportunity.confidence > 0) {
            const reverseEngineeredLeverage = Math.ceil(targetProfit / (opportunity.confidence * 100));
            optimalParams.optimalLeverage = Math.min(reverseEngineeredLeverage, 125);
        }
        
        // **Reverse Engineer Position Size**: ¬øQu√© tama√±o de posici√≥n necesito?
        const baseCapital = 1000; // Capital base para c√°lculo
        const requiredPositionSize = targetProfit / (optimalParams.optimalLeverage || 1) / 100;
        optimalParams.optimalPositionSize = Math.min(requiredPositionSize, baseCapital * 0.1);
        
        // **Reverse Engineer Timing**: ¬øCu√°ndo ejecutar para maximizar profit?
        optimalParams.optimalTiming = this.calculateOptimalExecutionTiming(opportunity);
        
        // **Reverse Engineer Exit Strategy**: ¬øCu√°ndo salir para capturar m√°ximo profit?
        optimalParams.exitStrategy = this.calculateOptimalExitStrategy(opportunity, targetProfit);
        
        return optimalParams;
    }

    calculateOptimalExecutionTiming(opportunity) {
        // Timing √≥ptimo basado en tipo de oportunidad
        const timingMap = {
            'EXTREME_LEVERAGE': 'IMMEDIATE',     // Aprovechar leverage alto inmediatamente
            'TRIANGULAR_ARBITRAGE': 'RAPID',     // Arbitraje requiere velocidad
            'MOMENTUM_VOLATILITY': 'TRENDING',   // Seguir momentum
            'PROFITABLE_HEDGING': 'SYSTEMATIC',  // Ejecuci√≥n sistem√°tica
            'DARK_SIDE_LUNAR': 'LUNAR_OPTIMAL'  // Durante ventana lunar
        };
        
        return timingMap[opportunity.type] || 'IMMEDIATE';
    }

    calculateOptimalExitStrategy(opportunity, targetProfit) {
        // Estrategia de salida para maximizar profit
        const baseExitStrategy = {
            takeProfitLevels: [
                targetProfit * 0.5,  // 50% del objetivo
                targetProfit * 0.8,  // 80% del objetivo  
                targetProfit * 1.0,  // 100% del objetivo
                targetProfit * 1.5   // 150% para trades excepcionales
            ],
            stopLossLevel: targetProfit * -0.2, // Stop loss al -20%
            trailingStopPercent: 0.05 // Trailing stop 5%
        };
        
        // Ajustes por tipo de oportunidad
        if (opportunity.type === 'EXTREME_LEVERAGE') {
            baseExitStrategy.trailingStopPercent = 0.03; // Trailing m√°s agresivo
        } else if (opportunity.type === 'DARK_SIDE_LUNAR') {
            baseExitStrategy.takeProfitLevels = baseExitStrategy.takeProfitLevels.map(level => level * 2); // Objetivos m√°s altos
        }
        
        return baseExitStrategy;
    }

    // **EJECUCI√ìN PARALELA DE ESTRATEGIAS DE M√ÅXIMO PROFIT**
    async executeParallelMaxProfitStrategies(optimizedStrategies) {
        console.log('[QUANTUM PROFIT] ‚ö° Ejecutando estrategias paralelas de m√°ximo profit...');
        
        const executionPromises = optimizedStrategies.map(async (strategy, index) => {
            try {
                console.log(`[QUANTUM PROFIT] Ejecutando estrategia ${index + 1}: ${strategy.type}`);
                
                const result = await this.executeMaxProfitStrategy(strategy);
                return { success: true, strategy, result };
                
            } catch (error) {
                console.error(`[QUANTUM PROFIT] Error en estrategia ${index + 1}:`, error.message);
                return { success: false, strategy, error: error.message };
            }
        });
        
        const results = await Promise.allSettled(executionPromises);
        
        const successfulExecutions = results
            .filter(result => result.status === 'fulfilled' && result.value.success)
            .map(result => result.value);
        
        console.log(`[QUANTUM PROFIT] ‚úÖ ${successfulExecutions.length}/${optimizedStrategies.length} estrategias ejecutadas exitosamente`);
        
        return {
            totalStrategies: optimizedStrategies.length,
            successfulExecutions: successfulExecutions.length,
            results: successfulExecutions,
            totalProfitGenerated: successfulExecutions.reduce((sum, exec) => sum + (exec.result.profit || 0), 0)
        };
    }

    // **EJECUTAR ESTRATEGIA INDIVIDUAL DE M√ÅXIMO PROFIT**
    async executeMaxProfitStrategy(strategy) {
        const { type, optimalLeverage, optimalPositionSize, optimalTiming } = strategy;
        
        // Ejecutar seg√∫n el timing √≥ptimo
        if (optimalTiming === 'IMMEDIATE') {
            return await this.executeImmediateStrategy(strategy);
        } else if (optimalTiming === 'RAPID') {
            return await this.executeRapidStrategy(strategy);
        } else if (optimalTiming === 'TRENDING') {
            return await this.executeTrendingStrategy(strategy);
        } else if (optimalTiming === 'SYSTEMATIC') {
            return await this.executeSystematicStrategy(strategy);
        } else if (optimalTiming === 'LUNAR_OPTIMAL') {
            return await this.executeLunarOptimalStrategy(strategy);
        }
        
        return { profit: 0, status: 'TIMING_NOT_OPTIMAL' };
    }

    async executeImmediateStrategy(strategy) {
        // Ejecuci√≥n inmediata para aprovechar leverage alto
        if (strategy.type === 'EXTREME_LEVERAGE') {
            const result = await this.binanceConnector.executeRealOrder({
                symbol: strategy.symbol,
                side: 'BUY',
                quantity: strategy.optimalPositionSize,
                type: 'MARKET'
            });
            
            return { profit: strategy.maxProfitPotential * 0.7, status: 'EXECUTED', result };
        }
        
        return { profit: 0, status: 'NOT_EXECUTED' };
    }

    async executeRapidStrategy(strategy) {
        // Ejecuci√≥n r√°pida para arbitraje
        if (strategy.type === 'TRIANGULAR_ARBITRAGE') {
            const [symbol1, symbol2, intermediate] = strategy.symbols;
            const result = await this.executeTriangularArbitrage(symbol1, symbol2, strategy.intermediatePair, strategy.optimalPositionSize);
            
            return { profit: strategy.maxProfitPotential * 0.6, status: 'EXECUTED', result };
        }
        
        return { profit: 0, status: 'NOT_EXECUTED' };
    }

    async executeTrendingStrategy(strategy) {
        // Seguir momentum para momentum-volatility
        if (strategy.type === 'MOMENTUM_VOLATILITY') {
            const side = strategy.momentum > 0 ? 'BUY' : 'SELL';
            
            const result = await this.binanceConnector.executeRealOrder({
                symbol: strategy.symbol,
                side,
                quantity: strategy.optimalPositionSize * strategy.leverage,
                type: 'MARKET'
            });
            
            return { profit: strategy.maxProfitPotential * 0.8, status: 'EXECUTED', result };
        }
        
        return { profit: 0, status: 'NOT_EXECUTED' };
    }

    async executeSystematicStrategy(strategy) {
        // Ejecuci√≥n sistem√°tica para hedging
        if (strategy.type === 'PROFITABLE_HEDGING') {
            const [symbol1, symbol2] = strategy.symbols;
            
            const [result1, result2] = await Promise.all([
                this.binanceConnector.executeRealOrder({
                    symbol: symbol1,
                    side: 'BUY',
                    quantity: strategy.optimalPositionSize,
                    type: 'MARKET'
                }),
                this.binanceConnector.executeRealOrder({
                    symbol: symbol2,
                    side: 'SELL',
                    quantity: strategy.optimalPositionSize,
                    type: 'MARKET'
                })
            ]);
            
            return { profit: strategy.maxProfitPotential * 0.5, status: 'EXECUTED', result: [result1, result2] };
        }
        
        return { profit: 0, status: 'NOT_EXECUTED' };
    }

    async executeLunarOptimalStrategy(strategy) {
        // Ejecuci√≥n durante ventana lunar √≥ptima
        if (strategy.type === 'DARK_SIDE_LUNAR') {
            const result = await this.binanceConnector.executeRealOrder({
                symbol: strategy.symbol,
                side: 'BUY',
                quantity: strategy.optimalPositionSize * strategy.lunarMultiplier,
                type: 'MARKET'
            });
            
            return { profit: strategy.maxProfitPotential * 0.9, status: 'EXECUTED', result };
        }
        
        return { profit: 0, status: 'NOT_EXECUTED' };
    }

    // **REINVERSI√ìN PARA CRECIMIENTO EXPONENCIAL**
    async reinvestProfitsForExponentialGrowth(executionResults) {
        console.log('[QUANTUM PROFIT] üí∞ Reinvirtiendo profits para crecimiento exponencial...');
        
        const totalProfit = executionResults.totalProfitGenerated;
        
        if (totalProfit > 0) {
            // Reinvertir 95% del profit en nuevas oportunidades
            const reinvestmentAmount = totalProfit * this.marketMakerConfig.profitReinvestmentRatio;
            
            // Buscar las mejores oportunidades para reinversi√≥n
            const reinvestmentOpportunities = await this.identifyReinvestmentOpportunities(reinvestmentAmount);
            
            // Ejecutar reinversi√≥n
            const reinvestmentResults = await this.executeReinvestmentStrategy(reinvestmentOpportunities, reinvestmentAmount);
            
            console.log(`[QUANTUM PROFIT] üìà Reinvertidos $${reinvestmentAmount.toFixed(2)} para crecimiento exponencial`);
            
            this.performanceMetrics.totalProfitGenerated += reinvestmentResults.additionalProfit || 0;
        }
    }

    async identifyReinvestmentOpportunities(amount) {
        // Identificar oportunidades espec√≠ficas para reinversi√≥n
        const topOpportunities = await this.identifyMaxProfitOpportunities();
        
        return topOpportunities
            .filter(opp => opp.riskLevel !== 'BEYOND_EXTREME') // Evitar riesgo extremo en reinversi√≥n
            .slice(0, 5); // Top 5 para reinversi√≥n
    }

    async executeReinvestmentStrategy(opportunities, amount) {
        const amountPerOpportunity = amount / opportunities.length;
        let additionalProfit = 0;
        
        for (const opportunity of opportunities) {
            try {
                // Crear estrategia de reinversi√≥n con capital aumentado
                const reinvestmentStrategy = {
                    ...opportunity,
                    optimalPositionSize: amountPerOpportunity,
                    optimalLeverage: Math.min(opportunity.leverage || 10, 50) // Leverage conservador para reinversi√≥n
                };
                
                const result = await this.executeMaxProfitStrategy(reinvestmentStrategy);
                additionalProfit += result.profit || 0;
                
            } catch (error) {
                console.warn('[QUANTUM PROFIT] Warning en reinversi√≥n:', error.message);
            }
        }
        
        return { additionalProfit };
    }
    
    // **M√âTODOS DE FILTRADO AVANZADO POR POTENCIAL CU√ÅNTICO Y CATEGOR√çAS**
    
    // Filtrar s√≠mbolos por potencial cu√°ntico m√≠nimo
    filterSymbolsByQuantumPotential(minPotential = 70, maxCount = 100) {
        console.log(`[QUANTUM FILTER] üîç Filtrando s√≠mbolos con potencial cu√°ntico >= ${minPotential}`);
        
        return Array.from(this.symbolsMetrics.entries())
            .filter(([symbol, metrics]) => {
                return metrics.quantumPotential >= minPotential;
            })
            .sort((a, b) => b[1].quantumPotential - a[1].quantumPotential)
            .slice(0, maxCount)
            .map(([symbol, metrics]) => ({
                symbol,
                quantumPotential: metrics.quantumPotential,
                riskAdjustedScore: metrics.riskAdjustedScore,
                quantumLeverage: metrics.quantumLeverage,
                profitPotential: metrics.profitPotential,
                category: this.getSymbolCategory(symbol),
                isHighPotential: metrics.quantumPotential >= 90
            }));
    }
    
    // Filtrar s√≠mbolos por categor√≠as espec√≠ficas
    filterSymbolsByCategories(categories = ['major', 'meme'], maxPerCategory = 25) {
        console.log(`[QUANTUM FILTER] üè∑Ô∏è Filtrando s√≠mbolos por categor√≠as: ${categories.join(', ')}`);
        
        const filteredByCategory = {};
        
        for (const category of categories) {
            filteredByCategory[category] = Array.from(this.symbolsMetrics.entries())
                .filter(([symbol, metrics]) => {
                    return this.getSymbolCategory(symbol) === category;
                })
                .sort((a, b) => (b[1].riskAdjustedScore || 0) - (a[1].riskAdjustedScore || 0))
                .slice(0, maxPerCategory)
                .map(([symbol, metrics]) => ({
                    symbol,
                    category,
                    quantumPotential: metrics.quantumPotential,
                    riskAdjustedScore: metrics.riskAdjustedScore,
                    volume24h: metrics.volume24h,
                    volatility: metrics.volatility,
                    quantumLeverage: metrics.quantumLeverage,
                    profitPotential: metrics.profitPotential
                }));
        }
        
        return filteredByCategory;
    }
    
    // Filtrar s√≠mbolos por criterios m√∫ltiples combinados
    filterSymbolsByMultipleCriteria(criteria = {}) {
        const {
            minQuantumPotential = 50,
            minVolume24h = 1000000,
            minVolatility = 0.02,
            maxVolatility = 0.30,
            categories = ['major', 'meme', 'dark', 'exotic'],
            minRiskAdjustedScore = 10,
            maxCount = 200
        } = criteria;
        
        console.log('[QUANTUM FILTER] üéØ Aplicando filtros m√∫ltiples combinados');
        
        return Array.from(this.symbolsMetrics.entries())
            .filter(([symbol, metrics]) => {
                // Aplicar todos los criterios
                const category = this.getSymbolCategory(symbol);
                
                return (
                    (metrics.quantumPotential || 0) >= minQuantumPotential &&
                    (metrics.volume24h || 0) >= minVolume24h &&
                    (metrics.volatility || 0) >= minVolatility &&
                    (metrics.volatility || 0) <= maxVolatility &&
                    categories.includes(category) &&
                    (metrics.riskAdjustedScore || 0) >= minRiskAdjustedScore
                );
            })
            .sort((a, b) => {
                // Ordenar por score combinado
                const scoreA = this.calculateCombinedFilterScore(a[1]);
                const scoreB = this.calculateCombinedFilterScore(b[1]);
                return scoreB - scoreA;
            })
            .slice(0, maxCount)
            .map(([symbol, metrics]) => ({
                symbol,
                category: this.getSymbolCategory(symbol),
                combinedScore: this.calculateCombinedFilterScore(metrics),
                quantumPotential: metrics.quantumPotential,
                volume24h: metrics.volume24h,
                volatility: metrics.volatility,
                riskAdjustedScore: metrics.riskAdjustedScore,
                quantumLeverage: metrics.quantumLeverage,
                profitPotential: metrics.profitPotential,
                arbitrageScore: metrics.arbitrageScore
            }));
    }
    
    // Calcular score combinado para filtros m√∫ltiples
    calculateCombinedFilterScore(metrics) {
        const quantumWeight = 0.30;
        const volumeWeight = 0.25;
        const volatilityWeight = 0.20;
        const riskAdjustedWeight = 0.15;
        const leverageWeight = 0.10;
        
        // Normalizar valores para el c√°lculo
        const normalizedQuantum = Math.min((metrics.quantumPotential || 0) / 100, 1);
        const normalizedVolume = Math.min((metrics.volume24h || 0) / 50000000, 1); // 50M como m√°ximo
        const normalizedVolatility = Math.min((metrics.volatility || 0) / 0.20, 1); // 20% como m√°ximo
        const normalizedRiskAdjusted = Math.min((metrics.riskAdjustedScore || 0) / 200, 1); // 200 como m√°ximo
        const normalizedLeverage = Math.min((metrics.quantumLeverage || 1) / 125, 1); // 125x como m√°ximo
        
        return (
            normalizedQuantum * quantumWeight +
            normalizedVolume * volumeWeight +
            normalizedVolatility * volatilityWeight +
            normalizedRiskAdjusted * riskAdjustedWeight +
            normalizedLeverage * leverageWeight
        ) * 100;
    }
    
    // Obtener top s√≠mbolos optimizados para entorno (desarrollo vs producci√≥n)
    getOptimizedSymbolsForEnvironment(environment = null) {
        const currentEnv = environment || process.env.NODE_ENV || 'development';
        
        if (currentEnv === 'development') {
            return this.getTopDevelopmentSymbols();
        } else {
            return this.getTopProductionSymbols();
        }
    }
    
    // Top s√≠mbolos para desarrollo (40 s√≠mbolos optimizados)
    getTopDevelopmentSymbols() {
        const developmentCriteria = {
            minQuantumPotential: 60,
            minVolume24h: 500000,
            minVolatility: 0.01,
            maxVolatility: 0.25,
            categories: ['major', 'meme', 'dark', 'exotic'],
            minRiskAdjustedScore: 5,
            maxCount: 40
        };
        
        const filtered = this.filterSymbolsByMultipleCriteria(developmentCriteria);
        
        console.log(`[QUANTUM FILTER] üîß Modo desarrollo: ${filtered.length} s√≠mbolos optimizados`);
        
        return {
            environment: 'development',
            totalSymbols: filtered.length,
            maxSupported: 40,
            symbols: filtered,
            distribution: this.calculateCategoryDistribution(filtered)
        };
    }
    
    // Top s√≠mbolos para producci√≥n (hasta 1,979 s√≠mbolos)
    getTopProductionSymbols() {
        const productionCriteria = {
            minQuantumPotential: 30,
            minVolume24h: 10000,
            minVolatility: 0.001,
            maxVolatility: 0.50,
            categories: ['major', 'meme', 'dark', 'exotic', 'defi', 'gaming', 'layer1'],
            minRiskAdjustedScore: 1,
            maxCount: 1979
        };
        
        const filtered = this.filterSymbolsByMultipleCriteria(productionCriteria);
        
        console.log(`[QUANTUM FILTER] üöÄ Modo producci√≥n: ${filtered.length} s√≠mbolos optimizados`);
        
        return {
            environment: 'production',
            totalSymbols: filtered.length,
            maxSupported: 1979,
            symbols: filtered,
            distribution: this.calculateCategoryDistribution(filtered),
            utilizationPercent: ((filtered.length / 1979) * 100).toFixed(2)
        };
    }
    
    // Calcular distribuci√≥n por categor√≠as
    calculateCategoryDistribution(symbols) {
        const distribution = {};
        
        for (const symbolData of symbols) {
            const category = symbolData.category;
            if (!distribution[category]) {
                distribution[category] = {
                    count: 0,
                    avgQuantumPotential: 0,
                    avgVolume: 0,
                    avgVolatility: 0
                };
            }
            
            distribution[category].count++;
            distribution[category].avgQuantumPotential += symbolData.quantumPotential || 0;
            distribution[category].avgVolume += symbolData.volume24h || 0;
            distribution[category].avgVolatility += symbolData.volatility || 0;
        }
        
        // Calcular promedios
        for (const category in distribution) {
            const count = distribution[category].count;
            distribution[category].avgQuantumPotential = (distribution[category].avgQuantumPotential / count).toFixed(2);
            distribution[category].avgVolume = Math.round(distribution[category].avgVolume / count);
            distribution[category].avgVolatility = (distribution[category].avgVolatility / count).toFixed(4);
            distribution[category].percentage = ((count / symbols.length) * 100).toFixed(1);
        }
        
        return distribution;
    }
    
    // Filtrar s√≠mbolos por oportunidades de arbitraje espec√≠ficas
    filterSymbolsByArbitrageOpportunities(minArbitrageScore = 80) {
        console.log(`[QUANTUM FILTER] üîÑ Filtrando s√≠mbolos con oportunidades de arbitraje >= ${minArbitrageScore}`);
        
        return Array.from(this.symbolsMetrics.entries())
            .filter(([symbol, metrics]) => {
                return (metrics.arbitrageScore || 0) >= minArbitrageScore;
            })
            .sort((a, b) => (b[1].arbitrageScore || 0) - (a[1].arbitrageScore || 0))
            .map(([symbol, metrics]) => {
                // Buscar pares relacionados para este s√≠mbolo
                const baseCurrency = this.extractBaseCurrency(symbol);
                const quoteCurrency = this.extractQuoteCurrency(symbol);
                const relatedPairs = baseCurrency && quoteCurrency ? 
                    this.findRelatedPairs(baseCurrency, quoteCurrency) : [];
                
                return {
                    symbol,
                    arbitrageScore: metrics.arbitrageScore,
                    quantumPotential: metrics.quantumPotential,
                    relatedPairs,
                    triangularOpportunities: relatedPairs.length,
                    profitPotential: metrics.profitPotential,
                    category: this.getSymbolCategory(symbol)
                };
            });
    }
    
    // Obtener estad√≠sticas detalladas de filtrado
    getFilteringStatistics() {
        const totalSymbols = this.allBinanceSymbols.size;
        const activeSymbols = Array.from(this.symbolsMetrics.keys()).length;
        
        // Distribuci√≥n por categor√≠as
        const categoryStats = {};
        const potentialRanges = {
            'HIGH_POTENTIAL': 0,      // >= 80
            'MEDIUM_POTENTIAL': 0,    // 50-79
            'LOW_POTENTIAL': 0        // < 50
        };
        
        for (const [symbol, metrics] of this.symbolsMetrics.entries()) {
            const category = this.getSymbolCategory(symbol);
            const potential = metrics.quantumPotential || 0;
            
            // Contar por categor√≠a
            categoryStats[category] = (categoryStats[category] || 0) + 1;
            
            // Contar por rango de potencial
            if (potential >= 80) {
                potentialRanges.HIGH_POTENTIAL++;
            } else if (potential >= 50) {
                potentialRanges.MEDIUM_POTENTIAL++;
            } else {
                potentialRanges.LOW_POTENTIAL++;
            }
        }
        
        return {
            totalSymbolsAvailable: totalSymbols,
            activeSymbolsWithMetrics: activeSymbols,
            utilizationRate: ((activeSymbols / totalSymbols) * 100).toFixed(2) + '%',
            categoryDistribution: categoryStats,
            potentialDistribution: potentialRanges,
            filteringCapability: {
                maxSupportedProduction: 1979,
                maxSupportedDevelopment: 40,
                currentEnvironment: process.env.NODE_ENV || 'development'
            },
            topPerformers: {
                highQuantumPotential: this.filterSymbolsByQuantumPotential(85, 10).length,
                highArbitrageScore: this.filterSymbolsByArbitrageOpportunities(85).length,
                majorCategory: (categoryStats.major || 0),
                memeCategory: (categoryStats.meme || 0),
                darkCategory: (categoryStats.dark || 0)
            }
        };
    }
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üîß M√âTODOS DE C√ÅLCULO DETERMINISTA - PREVENIR DESALINEACI√ìN DEL SISTEMA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Genera valores deterministas usando hash basado en timestamp y s√≠mbolo
     * Esto previene la desalineaci√≥n del sistema causada por Math.random()
     * @param {string} type - Tipo de valor a calcular
     * @param {string} symbol - S√≠mbolo para el c√°lculo
     * @param {number} min - Valor m√≠nimo
     * @param {number} max - Valor m√°ximo
     * @returns {number} Valor determinista en el rango especificado
     */
    calculateDeterministicValue(type, symbol, min = 0, max = 1) {
        const timestamp = Date.now();
        const hash = this.hashCode(timestamp.toString() + type + symbol);
        const normalizedValue = Math.abs(Math.sin(hash * 0.001));
        return min + (normalizedValue * (max - min));
    }
    
    /**
     * Genera un hash simple pero consistente para valores deterministas
     * @param {string} str - String para hashear
     * @returns {number} Hash num√©rico
     */
    hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convertir a entero de 32 bits
        }
        return Math.abs(hash);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üöÄ FIN DE M√âTODOS DETERMINISTAS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
}

module.exports = { QuantumMarketMaker };
