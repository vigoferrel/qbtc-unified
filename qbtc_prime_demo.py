# -*- coding: utf-8 -*-
"""
Demostraci√≥n Completa del Sistema QBTC Integrado
Sistema de Utilidades de N√∫meros Primos con Resonancias Cu√°nticas Avanzadas

Muestra todas las funcionalidades del sistema h√≠brido QuantumLeverageEngine + QBTC
"""

import time
from prime_resonance_utils import PrimeResonanceEngine
from quantum_resonance_config import QBTCConstants, QUANTUM_CONFIG
import logging

# Configuraci√≥n de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('QBTCPrimeDemo')

def print_header(title: str, width: int = 80):
    """Imprime un header formateado"""
    print("=" * width)
    print(f"{title:^{width}}")
    print("=" * width)

def print_section(title: str, width: int = 60):
    """Imprime un header de secci√≥n"""
    print(f"\n{'-' * width}")
    print(f"{title}")
    print(f"{'-' * width}")

def demonstrate_qbtc_constants():
    """Demuestra las constantes QBTC integradas"""
    print_section("üî¨ CONSTANTES CU√ÅNTICAS QBTC INTEGRADAS")
    
    print(f"Variable Compleja Fundamental:")
    print(f"  Z_COMPLEX = {QBTCConstants.Z_COMPLEX}")
    print(f"  |Z| = {QBTCConstants.Z_MAGNITUDE:.6f}")
    print(f"  Re(Z) = {QBTCConstants.Z_REAL}")
    print(f"  Im(Z) = {QBTCConstants.Z_IMAG}")
    
    print(f"\nPrimo Fundamental y Lambda:")
    print(f"  PRIME_7919 = {QBTCConstants.PRIME_7919}")
    print(f"  LAMBDA_7919 = ln(7919) = {QBTCConstants.LAMBDA_7919:.6f}")
    
    print(f"\nFactores de Modulaci√≥n Cu√°ntica:")
    print(f"  Modulaci√≥n Real = {QBTCConstants.QUANTUM_MODULATION_REAL:.6f}")
    print(f"  Modulaci√≥n Imaginaria = {QBTCConstants.QUANTUM_MODULATION_IMAG:.6f}")
    print(f"  Ratio Lambda/Z = {QBTCConstants.LAMBDA_Z_RATIO:.6f}")
    print(f"  Ratio Z/Lambda = {QBTCConstants.Z_LAMBDA_RATIO:.6f}")
    
    print(f"\nConstantes Matem√°ticas:")
    print(f"  Golden Ratio œÜ = {QBTCConstants.GOLDEN_RATIO:.6f}")
    print(f"  Euler e = {QBTCConstants.EULER_CONSTANT:.6f}")

def demonstrate_prime_generation():
    """Demuestra la generaci√≥n de primos con mejoras QBTC"""
    print_section("‚öõÔ∏è  GENERACI√ìN DE PRIMOS CON QBTC")
    
    engine = PrimeResonanceEngine()
    
    # Generar primos b√°sicos
    print("Generando primos hasta 500...")
    start_time = time.time()
    primes = engine.generate_primes_sieve(500)
    generation_time = time.time() - start_time
    
    print(f"‚úÖ Generados {len(primes)} primos en {generation_time:.4f} segundos")
    print(f"Primeros 15 primos: {primes[:15]}")
    print(f"√öltimos 10 primos: {primes[-10:]}")
    
    return primes, engine

def demonstrate_sacred_sequence_qbtc(engine):
    """Demuestra la generaci√≥n de secuencias sagradas con QBTC"""
    print_section("üåü SECUENCIA DE PRIMOS SAGRADOS CON RESONANCIA QBTC")
    
    print("Generando secuencia sagrada base (7 primos):")
    sacred_basic = engine.generate_sacred_prime_sequence(7)
    print(f"Base: {sacred_basic}")
    
    print(f"\nGenerando secuencia extendida con modulaci√≥n QBTC (20 primos):")
    start_time = time.time()
    sacred_extended = engine.generate_sacred_prime_sequence(20)
    qbtc_time = time.time() - start_time
    
    print(f"‚úÖ Secuencia QBTC generada en {qbtc_time:.4f} segundos")
    print(f"Secuencia completa: {sacred_extended}")
    
    # Mostrar diferencias entre base y modulada
    qbtc_additions = sacred_extended[7:]
    print(f"Primos agregados por modulaci√≥n QBTC: {qbtc_additions}")
    
    # Analizar propiedades QBTC de los nuevos primos
    print(f"\nAn√°lisis de resonancia QBTC de los nuevos primos:")
    for i, prime in enumerate(qbtc_additions[:5]):  # Solo primeros 5 para brevedad
        quantum_phase = QBTCConstants.get_quantum_phase(prime)
        z_mod = (prime * QBTCConstants.QUANTUM_MODULATION_REAL) % 1.0
        print(f"  {prime}: Fase cu√°ntica = {quantum_phase:.4f}, Z-modulaci√≥n = {z_mod:.4f}")
    
    return sacred_extended

def demonstrate_special_primes(engine, limit=1000):
    """Demuestra la b√∫squeda de tipos especiales de primos"""
    print_section("üîç B√öSQUEDA DE PRIMOS ESPECIALES")
    
    print(f"Buscando tipos especiales de primos hasta {limit}...")
    
    # Primos gemelos
    start_time = time.time()
    twins = engine.find_twin_primes(limit)
    twins_time = time.time() - start_time
    print(f"\nüë• Primos Gemelos:")
    print(f"   Encontrados: {len(twins)} pares en {twins_time:.4f}s")
    print(f"   Primeros 8 pares: {twins[:8]}")
    
    # Primos de Mersenne
    start_time = time.time()
    mersenne = engine.find_mersenne_primes(20)
    mersenne_time = time.time() - start_time
    print(f"\nüî¢ Primos de Mersenne (exp‚â§20):")
    print(f"   Encontrados: {len(mersenne)} primos en {mersenne_time:.4f}s")
    print(f"   Valores: {mersenne}")
    
    # Primos de Sophie Germain
    start_time = time.time()
    sophie = engine.find_sophie_germain_primes(300)
    sophie_time = time.time() - start_time
    print(f"\nüë∏ Primos de Sophie Germain (‚â§300):")
    print(f"   Encontrados: {len(sophie)} primos en {sophie_time:.4f}s")
    print(f"   Primeros 12: {sophie[:12]}")
    
    # Primos palindr√≥micos
    start_time = time.time()
    palindromic = engine.find_palindromic_primes(limit)
    palindromic_time = time.time() - start_time
    print(f"\nüîÑ Primos Palindr√≥micos:")
    print(f"   Encontrados: {len(palindromic)} primos en {palindromic_time:.4f}s")
    print(f"   Todos los valores: {palindromic}")
    
    return {
        'twins': twins,
        'mersenne': mersenne,
        'sophie': sophie,
        'palindromic': palindromic
    }

def demonstrate_qbtc_analysis(engine, primes):
    """Demuestra el an√°lisis avanzado QBTC"""
    print_section("üìä AN√ÅLISIS CU√ÅNTICO QBTC AVANZADO")
    
    # An√°lisis b√°sico
    print("Ejecutando an√°lisis b√°sico de patrones...")
    basic_analysis = engine.analyze_prime_patterns(primes[:100])
    
    print(f"\nüìà M√©tricas B√°sicas (primeros 100 primos):")
    print(f"   Total de primos: {basic_analysis['total_primes']}")
    print(f"   Rango: {basic_analysis['min_prime']} - {basic_analysis['max_prime']}")
    print(f"   Gap promedio: {basic_analysis['average_gap']:.2f}")
    print(f"   Gap m√°ximo: {basic_analysis['max_gap']}")
    print(f"   Primos gemelos: {basic_analysis['twin_prime_count']}")
    print(f"   Primos palindr√≥micos: {basic_analysis['palindromic_count']}")
    print(f"   Factor de resonancia: {basic_analysis['resonance_factor']:.4f}")
    
    # An√°lisis QBTC avanzado
    print(f"\nüåå Ejecutando an√°lisis QBTC completo...")
    start_time = time.time()
    qbtc_report = engine.get_qbtc_analysis_report(primes[:200])
    qbtc_time = time.time() - start_time
    
    print(f"‚úÖ An√°lisis QBTC completado en {qbtc_time:.4f} segundos")
    
    # Mostrar m√©tricas QBTC espec√≠ficas
    qbtc_metrics = qbtc_report['qbtc_metrics']
    print(f"\nüî¨ M√©tricas QBTC Avanzadas:")
    print(f"   Magnitud Z: {qbtc_metrics['z_complex_magnitude']:.6f}")
    print(f"   Lambda 7919: {qbtc_metrics['lambda_7919']:.6f}")
    print(f"   Golden Ratio: {qbtc_metrics['golden_ratio']:.6f}")
    print(f"   Coherencia Z-Modulaci√≥n: {qbtc_metrics['z_modulation_coherence']:.4f}")
    print(f"   Fuerza Resonancia Lambda: {qbtc_metrics['lambda_resonance_strength']:.4f}")
    print(f"   Densidad Primos Sagrados: {qbtc_metrics['sacred_prime_density']:.4f}")
    print(f"   Score Optimizaci√≥n QBTC: {qbtc_metrics['qbtc_optimization_score']:.4f}")
    
    # An√°lisis de distribuci√≥n de fase cu√°ntica
    phase_dist = qbtc_metrics['quantum_phase_distribution']
    print(f"\n‚ö° Distribuci√≥n de Fase Cu√°ntica (√∫ltimos 10 primos):")
    for i, phase in enumerate(phase_dist):
        prime = primes[-(10-i)]
        print(f"   Primo {prime}: Fase = {phase:.4f} rad")
    
    return qbtc_report

def demonstrate_performance_comparison():
    """Demuestra comparaci√≥n de rendimiento"""
    print_section("‚ö° COMPARACI√ìN DE RENDIMIENTO")
    
    engine = PrimeResonanceEngine()
    
    # Test de generaci√≥n de primos
    limits = [1000, 5000, 10000]
    
    for limit in limits:
        print(f"\nPrueba con l√≠mite {limit}:")
        
        # Generaci√≥n con criba
        start_time = time.time()
        primes = engine.generate_primes_sieve(limit)
        sieve_time = time.time() - start_time
        
        # An√°lisis QBTC
        start_time = time.time()
        qbtc_report = engine.get_qbtc_analysis_report(primes[:min(100, len(primes))])
        analysis_time = time.time() - start_time
        
        # Secuencia sagrada QBTC
        start_time = time.time()
        sacred = engine.generate_sacred_prime_sequence(15)
        sacred_time = time.time() - start_time
        
        print(f"   Generaci√≥n criba: {sieve_time:.4f}s ({len(primes)} primos)")
        print(f"   An√°lisis QBTC: {analysis_time:.4f}s")
        print(f"   Secuencia sagrada: {sacred_time:.4f}s")
        print(f"   Score QBTC: {qbtc_report['qbtc_metrics']['qbtc_optimization_score']:.4f}")

def main():
    """Funci√≥n principal de demostraci√≥n"""
    print_header("üöÄ DEMOSTRACI√ìN SISTEMA QBTC-PRIME INTEGRADO üöÄ")
    
    print(f"Sistema: QuantumLeverageEngine + QBTC Enhanced v1.0")
    print(f"Fecha: 2025-08-14")
    print(f"Integraci√≥n: Constantes cu√°nticas Z_COMPLEX y Lambda_7919")
    
    try:
        # 1. Mostrar constantes QBTC
        demonstrate_qbtc_constants()
        
        # 2. Generaci√≥n b√°sica de primos
        primes, engine = demonstrate_prime_generation()
        
        # 3. Secuencias sagradas con QBTC
        sacred_sequence = demonstrate_sacred_sequence_qbtc(engine)
        
        # 4. B√∫squeda de primos especiales
        special_primes = demonstrate_special_primes(engine)
        
        # 5. An√°lisis QBTC avanzado
        qbtc_report = demonstrate_qbtc_analysis(engine, primes)
        
        # 6. Comparaci√≥n de rendimiento
        demonstrate_performance_comparison()
        
        # Resumen final
        print_section("‚úÖ RESUMEN DE INTEGRACI√ìN EXITOSA")
        
        print(f"üî¨ Constantes QBTC integradas: ‚úì")
        print(f"   - Z_COMPLEX = {QBTCConstants.Z_COMPLEX}")
        print(f"   - Lambda_7919 = {QBTCConstants.LAMBDA_7919:.6f}")
        print(f"   - Primo fundamental = {QBTCConstants.PRIME_7919}")
        
        print(f"\n‚öõÔ∏è  Algoritmos mejorados: ‚úì")
        print(f"   - Resonancia cu√°ntica QBTC")
        print(f"   - Modulaci√≥n con variable compleja Z")
        print(f"   - An√°lisis de fase cu√°ntica")
        print(f"   - Optimizaci√≥n con Golden Ratio")
        
        print(f"\nüìä M√©tricas avanzadas: ‚úì")
        final_score = qbtc_report['qbtc_metrics']['qbtc_optimization_score']
        print(f"   - Score QBTC: {final_score:.4f}")
        print(f"   - Coherencia Z: {qbtc_report['qbtc_metrics']['z_modulation_coherence']:.4f}")
        print(f"   - Resonancia Lambda: {qbtc_report['qbtc_metrics']['lambda_resonance_strength']:.4f}")
        
        print(f"\nüéØ Estado del sistema: OPERACIONAL")
        print(f"üèÜ Integraci√≥n QBTC: EXITOSA")
        
        # Evaluaci√≥n final
        if final_score > 0.7:
            status = "EXCELENTE ‚≠ê‚≠ê‚≠ê"
        elif final_score > 0.5:
            status = "BUENO ‚≠ê‚≠ê"
        elif final_score > 0.3:
            status = "FUNCIONAL ‚≠ê"
        else:
            status = "B√ÅSICO"
        
        print(f"üìà Evaluaci√≥n final: {status}")
        
        print_header("üéâ DEMOSTRACI√ìN COMPLETADA EXITOSAMENTE üéâ")
        
        return True
        
    except Exception as e:
        logger.error(f"Error durante la demostraci√≥n: {e}")
        print(f"\n‚ùå Error en la demostraci√≥n: {e}")
        return False

if __name__ == "__main__":
    success = main()
    if success:
        print("\nüíæ Sistema listo para uso en producci√≥n")
        print("üìö Documentaci√≥n: Todos los m√©todos implementados y probados")
        print("üîß Mantenimiento: Logging activo para depuraci√≥n")
    else:
        print("\n‚ö†Ô∏è  Revisar errores antes del despliegue")
