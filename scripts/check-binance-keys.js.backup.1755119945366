#!/usr/bin/env node
/*
  QBTC BINANCE KEY CHECKER - Versi√≥n Simplificada sin Dependencias
  Analiza las claves API configuradas y detecta problemas de IP whitelist
*/

const https = require('https');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

class SimpleBinanceChecker {
    constructor() {
        this.envPath = path.join(__dirname, '..', '.env');
        this.loadEnvConfig();
        this.issues = [];
        this.solutions = [];
        this.currentIP = null;
    }

    loadEnvConfig() {
        try {
            const envContent = fs.readFileSync(this.envPath, 'utf8');
            this.envVars = {};
            
            envContent.split('\n').forEach(line => {
                if (line.includes('=') && !line.startsWith('#')) {
                    const [key, ...valueParts] = line.split('=');
                    this.envVars[key.trim()] = valueParts.join('=').trim();
                }
            });
        } catch (error) {
            console.error('‚ùå Error leyendo .env:', error.message);
            this.envVars = {};
        }
    }

    async checkAPI() {
        console.log('üéØ QBTC BINANCE KEY CHECKER v1.0');
        console.log('üîç Analizando configuraci√≥n sin dependencias externas...\n');
        
        console.log('üîç AN√ÅLISIS DE CLAVES API QBTC');
        console.log('===============================\n');

        const apiKey = this.envVars.BINANCE_API_KEY || '';
        const secretKey = this.envVars.BINANCE_SECRET_KEY || '';
        const isTestnet = this.envVars.BINANCE_TESTNET === 'true';

        console.log('üìã CONFIGURACI√ìN ACTUAL:');
        console.log(`   API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'NO CONFIGURADA'}`);
        console.log(`   Secret Key: ${secretKey ? `${secretKey.substring(0, 8)}...${secretKey.substring(secretKey.length - 8)}` : 'NO CONFIGURADA'}`);
        console.log(`   Modo Testnet: ${isTestnet ? '‚úÖ ACTIVADO' : '‚ùå DESACTIVADO'}`);
        console.log(`   IP Configurada: ${this.envVars.CURRENT_PUBLIC_IP || 'NO CONFIGURADA'}\n`);

        // Detectar IP actual
        await this.getCurrentIP();
        
        // Analizar formato de claves
        this.analyzeKeys(apiKey, secretKey);
        
        // Test de conectividad b√°sica
        await this.testConnectivity(isTestnet);
        
        // Mostrar resultados
        this.showResults();
        
        // Auto-actualizar IP si es necesario
        if (this.currentIP && this.issues.some(issue => issue.includes('IP'))) {
            await this.updateIPConfig();
        }
    }

    async getCurrentIP() {
        console.log('üåê DETECTANDO IP P√öBLICA...');
        
        return new Promise((resolve) => {
            const req = https.request({
                hostname: 'ipinfo.io',
                path: '/ip',
                method: 'GET',
                timeout: 5000
            }, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                    this.currentIP = data.trim();
                    console.log(`   ‚úÖ IP detectada: ${this.currentIP}`);
                    
                    // Comparar con IP configurada
                    const configuredIP = this.envVars.CURRENT_PUBLIC_IP;
                    if (configuredIP && configuredIP !== this.currentIP) {
                        this.issues.push(`‚ö†Ô∏è IP CAMBI√ì: Configurada=${configuredIP}, Actual=${this.currentIP}`);
                        this.solutions.push(`üîß Actualizar CURRENT_PUBLIC_IP=${this.currentIP} en .env`);
                        this.solutions.push('üîß Actualizar whitelist en Binance con nueva IP');
                    } else if (!configuredIP) {
                        this.issues.push('‚ùå IP no configurada en .env');
                        this.solutions.push(`üîß Agregar CURRENT_PUBLIC_IP=${this.currentIP} en .env`);
                    } else {
                        console.log('   ‚úÖ IP coincide con configuraci√≥n');
                    }
                    
                    resolve();
                });
            });

            req.on('error', (error) => {
                console.log(`   ‚ùå Error detectando IP: ${error.message}`);
                this.issues.push('‚ùå No se pudo detectar IP p√∫blica');
                resolve();
            });

            req.on('timeout', () => {
                console.log('   ‚è∞ Timeout detectando IP');
                this.issues.push('‚ùå Timeout detectando IP p√∫blica');
                req.destroy();
                resolve();
            });

            req.end();
        });
    }

    analyzeKeys(apiKey, secretKey) {
        console.log('\nüîë AN√ÅLISIS DE FORMATO DE CLAVES...');
        
        if (!apiKey || !secretKey) {
            this.issues.push('‚ùå Claves API no configuradas');
            this.solutions.push('üîß Configurar BINANCE_API_KEY y BINANCE_SECRET_KEY en .env');
            return;
        }

        // Verificar si son claves de ejemplo
        const demoPatterns = [
            'TU_API_KEY',
            'DEMO_KEY',
            'test_api_key',
            'your-api-key',
            'demo_api_key'
        ];

        let isDemo = false;
        demoPatterns.forEach(pattern => {
            if (apiKey.includes(pattern) || secretKey.includes(pattern)) {
                isDemo = true;
                this.issues.push(`‚ùå Claves contienen valores de ejemplo: ${pattern}`);
            }
        });

        if (isDemo) {
            this.solutions.push('üîß Reemplazar con claves reales de Binance API Management');
            return;
        }

        // Verificar longitud (claves reales de Binance suelen ser ~64 caracteres)
        if (apiKey.length < 60) {
            this.issues.push('‚ö†Ô∏è API Key muy corta (posible formato inv√°lido)');
        } else {
            console.log('   ‚úÖ API Key tiene longitud adecuada');
        }

        if (secretKey.length < 60) {
            this.issues.push('‚ö†Ô∏è Secret Key muy corta (posible formato inv√°lido)');
        } else {
            console.log('   ‚úÖ Secret Key tiene longitud adecuada');
        }

        // Verificar caracteres v√°lidos (solo alphanumeric)
        const validChars = /^[A-Za-z0-9]+$/;
        if (!validChars.test(apiKey)) {
            this.issues.push('‚ùå API Key contiene caracteres inv√°lidos');
        }
        if (!validChars.test(secretKey)) {
            this.issues.push('‚ùå Secret Key contiene caracteres inv√°lidos');
        }

        if (validChars.test(apiKey) && validChars.test(secretKey) && apiKey.length >= 60 && secretKey.length >= 60) {
            console.log('   ‚úÖ Formato de claves parece correcto');
        }
    }

    async testConnectivity(isTestnet) {
        console.log('\nüîó PROBANDO CONECTIVIDAD B√ÅSICA...');
        
        const hostname = isTestnet ? 'testnet.binancefuture.com' : 'fapi.binance.com';
        
        return new Promise((resolve) => {
            const req = https.request({
                hostname,
                path: '/fapi/v1/ping',
                method: 'GET',
                timeout: 5000
            }, (res) => {
                if (res.statusCode === 200) {
                    console.log('   ‚úÖ Conectividad b√°sica con Binance OK');
                } else {
                    console.log(`   ‚ö†Ô∏è Respuesta inesperada: ${res.statusCode}`);
                    this.issues.push(`‚ö†Ô∏è Respuesta HTTP ${res.statusCode} de Binance`);
                }
                resolve();
            });

            req.on('error', (error) => {
                console.log(`   ‚ùå Error de conectividad: ${error.message}`);
                this.issues.push(`‚ùå No se pudo conectar a Binance: ${error.message}`);
                this.solutions.push('üîß Verificar conectividad a internet');
                this.solutions.push('üîß Verificar firewall/proxy');
                resolve();
            });

            req.on('timeout', () => {
                console.log('   ‚è∞ Timeout conectando a Binance');
                this.issues.push('‚ùå Timeout conectando a Binance');
                req.destroy();
                resolve();
            });

            req.end();
        });
    }

    showResults() {
        console.log('\n' + '='.repeat(60));
        console.log('üìä DIAGN√ìSTICO FINAL QBTC');
        console.log('='.repeat(60));

        if (this.issues.length === 0) {
            console.log('üéâ ¬°CONFIGURACI√ìN B√ÅSICA CORRECTA!');
            console.log('‚úÖ Claves tienen formato v√°lido');
            console.log('‚úÖ Conectividad b√°sica funcional');
            console.log('\nüî∏ Para prueba completa de autenticaci√≥n, usar el sistema principal');
            return;
        }

        console.log('\n‚ùå PROBLEMAS DETECTADOS:');
        this.issues.forEach((issue, index) => {
            console.log(`   ${index + 1}. ${issue}`);
        });

        console.log('\nüîß SOLUCIONES RECOMENDADAS:');
        this.solutions.forEach((solution, index) => {
            console.log(`   ${index + 1}. ${solution}`);
        });

        console.log('\nüìã CONFIGURACI√ìN DE BINANCE API:');
        console.log('   1. Ir a https://www.binance.com/en/my/settings/api-management');
        console.log('   2. Crear nueva API Key o editar existente');
        console.log(`   3. Agregar IP en whitelist: ${this.currentIP || '[DETECTAR_IP_PRIMERO]'}`);
        console.log('   4. Permisos requeridos: ‚úÖ Reading, ‚úÖ Spot & Margin, ‚úÖ Futures');
        console.log('   5. Guardar y esperar 5-10 minutos para activaci√≥n');
        
        console.log('\nüö® IMPORTANTE PARA FUTUROS:');
        console.log('   ‚Ä¢ OBLIGATORIO: Configurar IP espec√≠fica en whitelist');
        console.log('   ‚Ä¢ Sin IP restringida NO funciona trading de futuros');
        console.log('   ‚Ä¢ Para testnet: usar testnet.binance.com para crear keys');
    }

    async updateIPConfig() {
        if (!this.currentIP) {
            console.log('\n‚ùå No se detect√≥ IP para actualizar configuraci√≥n');
            return;
        }

        console.log(`\nüîß ACTUALIZANDO IP EN CONFIGURACI√ìN...`);
        
        try {
            let envContent = fs.readFileSync(this.envPath, 'utf8');
            
            // Crear backup
            const backupPath = `${this.envPath}.backup.${Date.now()}`;
            fs.writeFileSync(backupPath, envContent);
            console.log(`   üìÅ Backup creado: ${path.basename(backupPath)}`);
            
            // Actualizar IP
            if (envContent.includes('CURRENT_PUBLIC_IP=')) {
                envContent = envContent.replace(
                    /CURRENT_PUBLIC_IP=.*/,
                    `CURRENT_PUBLIC_IP=${this.currentIP}`
                );
            } else {
                envContent += `\n# IP de conexi√≥n actual para whitelist\nCURRENT_PUBLIC_IP=${this.currentIP}\n`;
            }
            
            fs.writeFileSync(this.envPath, envContent);
            console.log(`   ‚úÖ IP actualizada a ${this.currentIP} en .env`);
            console.log(`   üîî Recuerda actualizar la whitelist en Binance tambi√©n`);
            
        } catch (error) {
            console.error(`   ‚ùå Error actualizando .env: ${error.message}`);
        }
    }
}

// Ejecutar
if (require.main === module) {
    const checker = new SimpleBinanceChecker();
    checker.checkAPI().catch(console.error);
}

module.exports = SimpleBinanceChecker;
