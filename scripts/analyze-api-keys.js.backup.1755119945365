#!/usr/bin/env node
/*
  QBTC API KEY ANALYZER AND IP FIXER
  Analiza las claves API configuradas y resuelve problemas de IP whitelist
*/

const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

class QBTCAPIAnalyzer {
    constructor() {
        this.envPath = path.join(__dirname, '..', '.env');
        this.loadEnvConfig();
        this.issues = [];
        this.solutions = [];
    }

    loadEnvConfig() {
        try {
            const envContent = fs.readFileSync(this.envPath, 'utf8');
            this.envVars = {};
            
            envContent.split('\n').forEach(line => {
                if (line.includes('=') && !line.startsWith('#')) {
                    const [key, ...valueParts] = line.split('=');
                    this.envVars[key.trim()] = valueParts.join('=').trim();
                }
            });
        } catch (error) {
            console.error('âŒ Error leyendo .env:', error.message);
            this.envVars = {};
        }
    }

    async analyzeAPIKeys() {
        console.log('ğŸ” ANÃLISIS DE CLAVES API QBTC');
        console.log('===============================\n');

        const apiKey = this.envVars.BINANCE_API_KEY || '';
        const secretKey = this.envVars.BINANCE_SECRET_KEY || '';
        const isTestnet = this.envVars.BINANCE_TESTNET === 'true';

        console.log('ğŸ“‹ CONFIGURACIÃ“N ACTUAL:');
        console.log(`   API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'NO CONFIGURADA'}`);
        console.log(`   Secret Key: ${secretKey ? `${secretKey.substring(0, 8)}...${secretKey.substring(secretKey.length - 8)}` : 'NO CONFIGURADA'}`);
        console.log(`   Modo Testnet: ${isTestnet ? 'âœ… ACTIVADO' : 'âŒ DESACTIVADO'}`);
        console.log(`   IP Configurada: ${this.envVars.CURRENT_PUBLIC_IP || 'NO CONFIGURADA'}\n`);

        // Verificar IP actual
        await this.checkCurrentIP();
        
        // Analizar claves
        this.analyzeKeyFormats(apiKey, secretKey);
        
        // Probar conexiÃ³n
        if (apiKey && secretKey) {
            await this.testBinanceConnection(apiKey, secretKey, isTestnet);
        }

        // Mostrar diagnÃ³stico final
        this.showDiagnostic();
    }

    async checkCurrentIP() {
        try {
            console.log('ğŸŒ VERIFICANDO IP PÃšBLICA ACTUAL...');
            
            // Intentar mÃºltiples servicios para obtener IP
            const ipServices = [
                'http://ipinfo.io/ip',
                'https://api.ipify.org',
                'http://checkip.amazonaws.com',
                'https://ifconfig.me/ip'
            ];

            let currentIP = null;
            
            for (const service of ipServices) {
                try {
                    const response = await axios.get(service, { timeout: 5000 });
                    currentIP = response.data.trim();
                    console.log(`   âœ… IP detectada: ${currentIP} (via ${service})`);
                    break;
                } catch (error) {
                    console.log(`   âš ï¸ Fallo ${service}: ${error.message}`);
                    continue;
                }
            }

            if (!currentIP) {
                this.issues.push('âŒ No se pudo detectar la IP pÃºblica');
                this.solutions.push('ğŸ”§ Verificar conectividad a internet');
                return;
            }

            // Comparar con IP configurada
            const configuredIP = this.envVars.CURRENT_PUBLIC_IP;
            if (configuredIP && configuredIP !== currentIP) {
                this.issues.push(`âš ï¸ IP CAMBIÃ“: Configurada=${configuredIP}, Actual=${currentIP}`);
                this.solutions.push(`ğŸ”§ Actualizar CURRENT_PUBLIC_IP=${currentIP} en .env`);
                this.solutions.push('ğŸ”§ Actualizar whitelist en Binance con nueva IP');
            } else if (!configuredIP) {
                this.issues.push('âŒ IP no configurada en .env');
                this.solutions.push(`ğŸ”§ Agregar CURRENT_PUBLIC_IP=${currentIP} en .env`);
            } else {
                console.log('   âœ… IP coincide con configuraciÃ³n');
            }

            this.currentIP = currentIP;
            
        } catch (error) {
            console.error('âŒ Error verificando IP:', error.message);
            this.issues.push('âŒ Error verificando IP pÃºblica');
        }
    }

    analyzeKeyFormats(apiKey, secretKey) {
        console.log('\nğŸ”‘ ANÃLISIS DE FORMATO DE CLAVES...');
        
        // Verificar si las claves son de ejemplo/demo
        const demoPatterns = [
            'TU_API_KEY',
            'DEMO_KEY',
            'test_api_key',
            'your-api-key',
            'demo_api_key'
        ];

        let isDemo = false;
        demoPatterns.forEach(pattern => {
            if (apiKey.includes(pattern) || secretKey.includes(pattern)) {
                isDemo = true;
                this.issues.push(`âŒ Claves contienen valores de ejemplo: ${pattern}`);
            }
        });

        if (isDemo) {
            this.solutions.push('ğŸ”§ Reemplazar con claves reales de Binance API Management');
            return;
        }

        // Verificar formato de claves reales de Binance
        if (apiKey.length < 60) {
            this.issues.push('âš ï¸ API Key muy corta (formato invÃ¡lido)');
        } else {
            console.log('   âœ… API Key tiene longitud correcta');
        }

        if (secretKey.length < 60) {
            this.issues.push('âš ï¸ Secret Key muy corta (formato invÃ¡lido)');
        } else {
            console.log('   âœ… Secret Key tiene longitud correcta');
        }

        // Verificar caracteres vÃ¡lidos
        const validChars = /^[A-Za-z0-9]+$/;
        if (!validChars.test(apiKey)) {
            this.issues.push('âŒ API Key contiene caracteres invÃ¡lidos');
        }
        if (!validChars.test(secretKey)) {
            this.issues.push('âŒ Secret Key contiene caracteres invÃ¡lidos');
        }
    }

    async testBinanceConnection(apiKey, secretKey, isTestnet) {
        console.log('\nğŸ”— PROBANDO CONEXIÃ“N CON BINANCE...');
        
        const baseURL = isTestnet 
            ? 'https://testnet.binancefuture.com'
            : 'https://fapi.binance.com';

        try {
            // Test 1: Ping bÃ¡sico
            console.log('   ğŸ“¡ Test 1: Ping bÃ¡sico...');
            await axios.get(`${baseURL}/fapi/v1/ping`, { timeout: 5000 });
            console.log('   âœ… Conectividad bÃ¡sica OK');

            // Test 2: Server Time
            console.log('   â° Test 2: SincronizaciÃ³n de tiempo...');
            const timeResponse = await axios.get(`${baseURL}/fapi/v1/time`, { timeout: 5000 });
            const serverTime = timeResponse.data.serverTime;
            const localTime = Date.now();
            const timeDiff = Math.abs(localTime - serverTime);
            
            if (timeDiff > 1000) {
                this.issues.push(`âš ï¸ Reloj desincronizado: ${timeDiff}ms de diferencia`);
                this.solutions.push('ğŸ”§ Sincronizar reloj del sistema (usar NTP)');
            } else {
                console.log('   âœ… SincronizaciÃ³n de tiempo OK');
            }

            // Test 3: AutenticaciÃ³n con API Key
            console.log('   ğŸ” Test 3: AutenticaciÃ³n...');
            
            const timestamp = Date.now();
            const queryString = `timestamp=${timestamp}`;
            const signature = crypto
                .createHmac('sha256', secretKey)
                .update(queryString)
                .digest('hex');

            const authResponse = await axios.get(`${baseURL}/fapi/v2/account`, {
                params: {
                    timestamp,
                    signature
                },
                headers: {
                    'X-MBX-APIKEY': apiKey
                },
                timeout: 10000
            });

            console.log('   âœ… AutenticaciÃ³n exitosa');
            console.log(`   ğŸ’° Balance disponible: ${authResponse.data.totalWalletBalance} USDT`);
            console.log(`   âš–ï¸ Positions: ${authResponse.data.positions?.length || 0} sÃ­mbolos`);

        } catch (error) {
            console.log('   âŒ Error de conexiÃ³n:', error.message);
            
            if (error.response) {
                const status = error.response.status;
                const data = error.response.data;
                
                console.log(`   ğŸ“Š Status: ${status}`);
                console.log(`   ğŸ“‹ Response: ${JSON.stringify(data, null, 2)}`);

                // Analizar errores especÃ­ficos
                if (status === 401) {
                    if (data.code === -2014 || data.code === -2015) {
                        this.issues.push('âŒ FORMATO DE API KEY INVÃLIDO');
                        this.solutions.push('ğŸ”§ Regenerar API Key en Binance');
                        this.solutions.push('ğŸ”§ Verificar que no haya espacios o caracteres especiales');
                    }
                    
                    if (data.msg && data.msg.includes('IP')) {
                        this.issues.push('âŒ IP NO ESTÃ EN WHITELIST DE BINANCE');
                        this.solutions.push(`ğŸ”§ Agregar IP ${this.currentIP} en Binance API Management`);
                        this.solutions.push('ğŸ”§ O deshabilitar restricciÃ³n de IP (solo para SPOT)');
                    }
                }
                
                if (status === 403) {
                    this.issues.push('âŒ PERMISOS INSUFICIENTES');
                    this.solutions.push('ğŸ”§ Habilitar "Enable Futures" en API Key');
                    this.solutions.push('ğŸ”§ Verificar que API Key no estÃ© suspendida');
                }
                
            } else {
                this.issues.push(`âŒ Error de red: ${error.message}`);
                this.solutions.push('ğŸ”§ Verificar conectividad a internet');
                this.solutions.push('ğŸ”§ Verificar firewall/proxy');
            }
        }
    }

    showDiagnostic() {
        console.log('\n' + '='.repeat(60));
        console.log('ğŸ“Š DIAGNÃ“STICO FINAL QBTC');
        console.log('='.repeat(60));

        if (this.issues.length === 0) {
            console.log('ğŸ‰ Â¡TODO ESTÃ CONFIGURADO CORRECTAMENTE!');
            console.log('âœ… Sistema listo para trading cuÃ¡ntico');
            return;
        }

        console.log('\nâŒ PROBLEMAS DETECTADOS:');
        this.issues.forEach((issue, index) => {
            console.log(`   ${index + 1}. ${issue}`);
        });

        console.log('\nğŸ”§ SOLUCIONES RECOMENDADAS:');
        this.solutions.forEach((solution, index) => {
            console.log(`   ${index + 1}. ${solution}`);
        });

        console.log('\nğŸ“‹ PASOS ESPECÃFICOS PARA BINANCE:');
        console.log('   1. Ir a https://www.binance.com/en/my/settings/api-management');
        console.log(`   2. Seleccionar tu API Key actual`);
        console.log(`   3. En "Restrict access to trusted IPs only" â†’ Enable`);
        console.log(`   4. Agregar IP: ${this.currentIP || '[IP_DETECTADA]'}`);
        console.log('   5. Asegurar permisos: âœ… Reading, âœ… Spot & Margin, âœ… Futures');
        console.log('   6. Guardar cambios y esperar 5-10 minutos');
        
        console.log('\nğŸš¨ IMPORTANTE:');
        console.log('   â€¢ Sin IP especÃ­fica habilitada NO puedes usar trading de futuros');
        console.log('   â€¢ Para mÃ¡xima seguridad, siempre usar IP restringida');
        console.log('   â€¢ Regenerar API Keys si hay problemas persistentes');
    }

    async fixIPConfiguration() {
        if (!this.currentIP) {
            console.log('âŒ No se pudo detectar IP para configurar');
            return;
        }

        console.log(`\nğŸ”§ ACTUALIZANDO CONFIGURACIÃ“N DE IP...`);
        
        try {
            let envContent = fs.readFileSync(this.envPath, 'utf8');
            
            // Actualizar o agregar IP actual
            if (envContent.includes('CURRENT_PUBLIC_IP=')) {
                envContent = envContent.replace(
                    /CURRENT_PUBLIC_IP=.*/,
                    `CURRENT_PUBLIC_IP=${this.currentIP}`
                );
            } else {
                envContent += `\n# IP de conexiÃ³n actual para whitelist\nCURRENT_PUBLIC_IP=${this.currentIP}\n`;
            }
            
            // Backup del .env actual
            const backupPath = `${this.envPath}.backup.${Date.now()}`;
            fs.writeFileSync(backupPath, fs.readFileSync(this.envPath));
            console.log(`   ğŸ“ Backup creado: ${backupPath}`);
            
            // Escribir nueva configuraciÃ³n
            fs.writeFileSync(this.envPath, envContent);
            console.log(`   âœ… IP actualizada a ${this.currentIP} en .env`);
            
        } catch (error) {
            console.error('âŒ Error actualizando .env:', error.message);
        }
    }
}

// Ejecutar anÃ¡lisis
async function main() {
    const analyzer = new QBTCAPIAnalyzer();
    
    console.log('ğŸ¯ QBTC API KEY ANALYZER v1.0');
    console.log('ğŸ” Analizando configuraciÃ³n y detectando problemas...\n');
    
    await analyzer.analyzeAPIKeys();
    
    // Preguntar si actualizar IP automÃ¡ticamente
    if (analyzer.currentIP && analyzer.issues.some(issue => issue.includes('IP'))) {
        console.log('\nâ“ Â¿Actualizar automÃ¡ticamente la IP en .env? (y/N)');
        // En un entorno real, usarÃ­as readline, pero por simplicidad...
        await analyzer.fixIPConfiguration();
    }
    
    console.log('\nğŸš€ AnÃ¡lisis completado. Revisar soluciones arriba.');
    console.log('ğŸ“– Para mÃ¡s informaciÃ³n: https://binance-docs.github.io/apidocs/futures/en/');
}

// Ejecutar si se llama directamente
if (require.main === module) {
    main().catch(console.error);
}

module.exports = QBTCAPIAnalyzer;
