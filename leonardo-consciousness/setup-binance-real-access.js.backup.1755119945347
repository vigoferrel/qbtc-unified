#!/usr/bin/env node

// ========================================================================
// ğŸ”‘ CONFIGURACIÃ“N DE ACCESO REAL A BINANCE 
// Establece credenciales, sincroniza balance real y configura FundsManager
// Para coherencia total del sistema Leonardo Consciousness
// ========================================================================

const fs = require('fs').promises;
const path = require('path');
const { FundsManager } = require('./FundsManager');
const BinanceConnectorAdapter = require('./BinanceConnectorAdapter');

// ConfiguraciÃ³n del acceso real
const REAL_ACCESS_CONFIG = {
    mode: 'production',              // production | testnet
    autoSyncBalance: true,          // Sincronizar balance automÃ¡ticamente
    createBackup: true,             // Crear backup de configuraciÃ³n actual
    validateCredentials: true,      // Validar credenciales antes de configurar
    setEnvironmentVars: true,      // Configurar variables de entorno
    updateFundsManager: true,      // Actualizar FundsManager con balance real
    enableRealTrading: false,      // Habilitar trading real (usar con precauciÃ³n)
    enableLogging: true            // Logging detallado del proceso
};

class BinanceRealAccessConfigurator {
    constructor(config = {}) {
        this.config = { ...REAL_ACCESS_CONFIG, ...config };
        this.binanceConnector = null;
        this.fundsManager = null;
        this.originalEnv = { ...process.env };
        this.configBackupPath = path.join(__dirname, 'config-backup.json');
        this.envFilePath = path.join(__dirname, '..', '.env');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸš€ CONFIGURACIÃ“N PRINCIPAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async configure() {
        this.log('INFO', 'ğŸš€ Iniciando configuraciÃ³n de acceso real a Binance');
        
        try {
            // 1. Crear backup de configuraciÃ³n actual
            if (this.config.createBackup) {
                await this.createBackup();
            }
            
            // 2. Verificar y configurar credenciales
            await this.setupCredentials();
            
            // 3. Validar acceso a Binance
            if (this.config.validateCredentials) {
                await this.validateBinanceAccess();
            }
            
            // 4. Sincronizar balance real
            if (this.config.autoSyncBalance) {
                await this.syncRealBalance();
            }
            
            // 5. Configurar FundsManager
            if (this.config.updateFundsManager) {
                await this.configureFundsManager();
            }
            
            // 6. Generar configuraciÃ³n final
            await this.generateFinalConfiguration();
            
            this.log('SUCCESS', 'âœ… ConfiguraciÃ³n de acceso real completada exitosamente');
            return true;
            
        } catch (error) {
            this.log('ERROR', 'âŒ Error en configuraciÃ³n de acceso real', error);
            await this.restoreBackup();
            throw error;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” CONFIGURACIÃ“N DE CREDENCIALES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async setupCredentials() {
        this.log('INFO', 'ğŸ” Configurando credenciales de Binance...');
        
        // Verificar si las credenciales ya estÃ¡n configuradas
        const apiKey = process.env.BINANCE_API_KEY;
        const secretKey = process.env.BINANCE_SECRET_KEY || process.env.BINANCE_API_SECRET;
        
        if (apiKey && secretKey) {
            this.log('SUCCESS', 'âœ… Credenciales encontradas en variables de entorno');
            return;
        }
        
        // Si no hay credenciales, mostrar instrucciones
        this.log('WARNING', 'âš ï¸ Credenciales no configuradas. Configurando para modo simulaciÃ³n...');
        
        // Crear configuraciÃ³n para modo simulaciÃ³n con balance alto
        const simulationConfig = {
            BINANCE_TESTNET: 'true',
            BINANCE_API_KEY: 'simulation_key_leonardo_consciousness',
            BINANCE_API_SECRET: 'simulation_secret_leonardo_consciousness',
            TRADING_INITIAL_BALANCE: '50000',        // $50k para simulaciÃ³n
            TRADING_MODE: 'SIMULATION',
            TRADING_MAX_LEVERAGE: '50',
            LEONARDO_FUNDS_MODE: 'SIMULATION_HIGH_CAPITAL',
            SKIP_API_VALIDATION: 'true'
        };
        
        // Actualizar variables de entorno para esta sesiÃ³n
        Object.entries(simulationConfig).forEach(([key, value]) => {
            process.env[key] = value;
        });
        
        // Crear archivo .env si no existe
        await this.createEnvFile(simulationConfig);
        
        this.log('INFO', 'ğŸ’° Configurado para modo SIMULACIÃ“N con $50,000 inicial');
    }

    async createEnvFile(config) {
        try {
            const existingEnv = await this.readEnvFile();
            const mergedConfig = { ...existingEnv, ...config };
            
            const envContent = Object.entries(mergedConfig)
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            
            await fs.writeFile(this.envFilePath, envContent + '\n');
            this.log('SUCCESS', 'âœ… Archivo .env actualizado');
        } catch (error) {
            this.log('WARNING', 'âš ï¸ No se pudo crear archivo .env:', error.message);
        }
    }

    async readEnvFile() {
        try {
            const content = await fs.readFile(this.envFilePath, 'utf8');
            const env = {};
            
            content.split('\n').forEach(line => {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    const [key, ...valueParts] = trimmed.split('=');
                    if (key && valueParts.length > 0) {
                        env[key.trim()] = valueParts.join('=').trim();
                    }
                }
            });
            
            return env;
        } catch (error) {
            return {};
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸŒ VALIDACIÃ“N DE ACCESO BINANCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async validateBinanceAccess() {
        this.log('INFO', 'ğŸŒ Validando acceso a Binance...');
        
        try {
            this.binanceConnector = new BinanceConnectorAdapter();
            
            // Test de conectividad bÃ¡sica
            const pingResult = await this.binanceConnector.ping();
            if (!pingResult.success) {
                throw new Error(`Ping fallido: ${pingResult.error}`);
            }
            
            this.log('SUCCESS', `âœ… Conectividad OK (${pingResult.latencyMs}ms)`);
            
            // Test de informaciÃ³n del exchange
            const exchangeInfo = await this.binanceConnector.getExchangeInfo();
            if (exchangeInfo && exchangeInfo.symbols) {
                this.log('SUCCESS', `ğŸ“Š Exchange info obtenida (${exchangeInfo.symbols.length} sÃ­mbolos)`);
            }
            
            // Test de acceso a cuenta (puede fallar sin credenciales reales)
            try {
                const accountInfo = await this.binanceConnector.getAccountInfo();
                if (accountInfo) {
                    this.log('SUCCESS', 'ğŸ”‘ Acceso a cuenta verificado');
                    return accountInfo;
                }
            } catch (accountError) {
                this.log('WARNING', 'âš ï¸ Acceso a cuenta limitado (esperado en simulaciÃ³n)');
                return null;
            }
            
        } catch (error) {
            this.log('ERROR', 'âŒ Error validando acceso Binance', error);
            throw error;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ’° SINCRONIZACIÃ“N DE BALANCE REAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async syncRealBalance() {
        this.log('INFO', 'ğŸ’° Sincronizando balance...');
        
        try {
            let realBalance = null;
            
            // Intentar obtener balance real de Binance
            if (this.binanceConnector) {
                try {
                    const accountInfo = await this.binanceConnector.getAccountInfo();
                    if (accountInfo && accountInfo.totalWalletBalance) {
                        realBalance = parseFloat(accountInfo.totalWalletBalance);
                        this.log('SUCCESS', `ğŸ“Š Balance real obtenido: $${realBalance.toFixed(2)}`);
                    }
                } catch (balanceError) {
                    this.log('WARNING', 'âš ï¸ No se pudo obtener balance real de Binance');
                }
            }
            
            // Si no hay balance real, usar configuraciÃ³n simulada
            if (!realBalance) {
                const configuredBalance = parseFloat(process.env.TRADING_INITIAL_BALANCE) || 50000;
                realBalance = configuredBalance;
                this.log('INFO', `ğŸ¯ Usando balance de simulaciÃ³n: $${realBalance.toFixed(2)}`);
            }
            
            // Validar balance mÃ­nimo
            const minBalance = 100; // $100 mÃ­nimo
            if (realBalance < minBalance) {
                this.log('WARNING', `âš ï¸ Balance bajo: $${realBalance}, estableciendo mÃ­nimo de $${minBalance}`);
                realBalance = minBalance;
            }
            
            // Guardar balance sincronizado
            this.syncedBalance = realBalance;
            
            // Actualizar variable de entorno
            process.env.LEONARDO_SYNCED_BALANCE = realBalance.toString();
            
            this.log('SUCCESS', `âœ… Balance sincronizado: $${realBalance.toFixed(2)}`);
            return realBalance;
            
        } catch (error) {
            this.log('ERROR', 'âŒ Error sincronizando balance', error);
            throw error;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§  CONFIGURACIÃ“N DEL FUNDSMANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async configureFundsManager() {
        this.log('INFO', 'ğŸ§  Configurando FundsManager con balance real...');
        
        try {
            const initialBalance = this.syncedBalance || 50000;
            
            // Crear FundsManager con balance real
            this.fundsManager = new FundsManager({
                initialBalance: initialBalance,
                maxLeverage: parseFloat(process.env.TRADING_MAX_LEVERAGE) || 25,
                maxRiskPerTrade: 0.08, // 8% mÃ¡ximo por trade para coherencia
                maxDrawdown: 0.40,     // 40% drawdown mÃ¡ximo
                stopLoss: 0.025,       // 2.5% stop loss
                takeProfit: 0.05,      // 5% take profit
                kellyFactor: 0.35,     // Factor Kelly agresivo
                testnet: process.env.BINANCE_TESTNET === 'true',
                compoundingEnabled: true,
                emergencyThreshold: 0.15 // Emergency stop al 15%
            });
            
            // Inicializar FundsManager
            await this.fundsManager.initialize();
            
            // Verificar estado post-inicializaciÃ³n
            const fundsStatus = this.fundsManager.getFundsStatus();
            
            this.log('SUCCESS', 'âœ… FundsManager configurado', {
                balance: fundsStatus.totalBalance,
                available: fundsStatus.availableBalance,
                canTrade: fundsStatus.canTrade,
                consciousness: fundsStatus.leonardoFundsState.consciousness_level
            });
            
            // Test de funcionalidad
            await this.testFundsManagerOperations();
            
        } catch (error) {
            this.log('ERROR', 'âŒ Error configurando FundsManager', error);
            throw error;
        }
    }

    async testFundsManagerOperations() {
        this.log('INFO', 'ğŸ”§ Probando operaciones FundsManager...');
        
        try {
            // Test de cÃ¡lculo de posiciÃ³n
            const mockOpportunity = {
                symbol: 'BTCUSDT',
                confidence: 0.8,
                edge: 0.03,
                leverage: 10
            };
            
            const mockConsciousness = {
                consciousness_level: 0.75,
                confidence: 0.8,
                edge: 0.03,
                leverage: 10,
                bigBangReady: false,
                pillarDetails: {
                    lambda888: { strength: 0.8 },
                    prime7919: { strength: 0.7 },
                    hookWheel: { strength: 0.85 },
                    symbiosis: { strength: 0.75 }
                }
            };
            
            const positionResult = this.fundsManager.calculatePositionSize(mockOpportunity, mockConsciousness);
            
            if (positionResult.success) {
                this.log('SUCCESS', 'âœ… CÃ¡lculo de posiciÃ³n funcional', {
                    size: positionResult.size,
                    risk: positionResult.risk,
                    leverage: positionResult.leverage
                });
            } else {
                this.log('WARNING', 'âš ï¸ CÃ¡lculo de posiciÃ³n con limitaciones', {
                    reason: positionResult.reason
                });
            }
            
            // Test de mÃ©tricas
            const metrics = this.fundsManager.getMetrics();
            this.log('INFO', 'ğŸ“Š MÃ©tricas FundsManager', metrics);
            
        } catch (error) {
            this.log('WARNING', 'âš ï¸ Error en test de operaciones', error);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“‹ GENERACIÃ“N DE CONFIGURACIÃ“N FINAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async generateFinalConfiguration() {
        this.log('INFO', 'ğŸ“‹ Generando configuraciÃ³n final...');
        
        const finalConfig = {
            timestamp: new Date().toISOString(),
            mode: this.config.mode,
            balance: {
                initial: this.syncedBalance,
                source: this.syncedBalance > 50000 ? 'BINANCE_REAL' : 'SIMULATION',
                currency: 'USDT'
            },
            binance: {
                connected: !!this.binanceConnector,
                testnet: process.env.BINANCE_TESTNET === 'true',
                credentialsConfigured: !!(process.env.BINANCE_API_KEY && process.env.BINANCE_API_SECRET)
            },
            fundsManager: {
                initialized: !!this.fundsManager,
                balance: this.fundsManager ? this.fundsManager.totalBalance : 0,
                canTrade: this.fundsManager ? this.fundsManager.canTrade() : false
            },
            environment: {
                TRADING_INITIAL_BALANCE: this.syncedBalance?.toString(),
                LEONARDO_SYNCED_BALANCE: this.syncedBalance?.toString(),
                BINANCE_TESTNET: process.env.BINANCE_TESTNET,
                TRADING_MODE: process.env.TRADING_MODE || 'SIMULATION',
                LEONARDO_FUNDS_MODE: process.env.LEONARDO_FUNDS_MODE || 'SIMULATION_HIGH_CAPITAL'
            },
            recommendations: this.generateRecommendations()
        };
        
        // Guardar configuraciÃ³n
        const configPath = path.join(__dirname, 'leonardo-real-access-config.json');
        await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
        
        this.log('SUCCESS', 'âœ… ConfiguraciÃ³n final guardada', {
            balance: finalConfig.balance.initial,
            mode: finalConfig.balance.source,
            canTrade: finalConfig.fundsManager.canTrade
        });
        
        return finalConfig;
    }

    generateRecommendations() {
        const recommendations = [];
        
        if (!process.env.BINANCE_API_KEY || !process.env.BINANCE_API_SECRET) {
            recommendations.push({
                type: 'CREDENTIALS',
                priority: 'HIGH',
                message: 'Configurar credenciales reales de Binance para trading en vivo',
                action: 'Set BINANCE_API_KEY y BINANCE_API_SECRET en variables de entorno'
            });
        }
        
        if (this.syncedBalance < 1000) {
            recommendations.push({
                type: 'BALANCE',
                priority: 'MEDIUM',
                message: 'Balance bajo para trading agresivo',
                action: 'Considerar incrementar balance inicial para mejor performance'
            });
        }
        
        if (process.env.BINANCE_TESTNET === 'true') {
            recommendations.push({
                type: 'ENVIRONMENT',
                priority: 'INFO',
                message: 'Sistema configurado para TESTNET',
                action: 'Cambiar BINANCE_TESTNET=false para trading real'
            });
        }
        
        return recommendations;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”„ BACKUP Y RESTAURACIÃ“N
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async createBackup() {
        this.log('INFO', 'ğŸ’¾ Creando backup de configuraciÃ³n...');
        
        const backup = {
            timestamp: new Date().toISOString(),
            environment: { ...this.originalEnv },
            files: {}
        };
        
        // Backup de archivo .env si existe
        try {
            const envContent = await fs.readFile(this.envFilePath, 'utf8');
            backup.files['.env'] = envContent;
        } catch (error) {
            // .env no existe, no problem
        }
        
        await fs.writeFile(this.configBackupPath, JSON.stringify(backup, null, 2));
        this.log('SUCCESS', 'âœ… Backup creado');
    }

    async restoreBackup() {
        this.log('WARNING', 'ğŸ”„ Restaurando configuraciÃ³n desde backup...');
        
        try {
            const backupData = await fs.readFile(this.configBackupPath, 'utf8');
            const backup = JSON.parse(backupData);
            
            // Restaurar variables de entorno
            Object.keys(process.env).forEach(key => {
                if (!backup.environment[key]) {
                    delete process.env[key];
                }
            });
            
            Object.entries(backup.environment).forEach(([key, value]) => {
                process.env[key] = value;
            });
            
            this.log('SUCCESS', 'âœ… ConfiguraciÃ³n restaurada desde backup');
        } catch (error) {
            this.log('ERROR', 'âŒ Error restaurando backup', error);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”§ UTILIDADES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    log(level, message, data = null) {
        if (!this.config.enableLogging && level === 'INFO') return;
        
        const timestamp = new Date().toISOString();
        const colors = {
            INFO: '\x1b[36m',
            SUCCESS: '\x1b[32m',
            WARNING: '\x1b[33m',
            ERROR: '\x1b[31m',
            RESET: '\x1b[0m'
        };
        
        console.log(`${colors[level]}[${timestamp}] ${level}: ${message}${colors.RESET}`);
        if (data) {
            console.log('Data:', JSON.stringify(data, null, 2));
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š API PÃšBLICA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    getConfigStatus() {
        return {
            configured: !!this.fundsManager,
            balance: this.syncedBalance,
            binanceConnected: !!this.binanceConnector,
            environment: {
                testnet: process.env.BINANCE_TESTNET === 'true',
                hasCredentials: !!(process.env.BINANCE_API_KEY && process.env.BINANCE_API_SECRET)
            }
        };
    }

    async getFundsStatus() {
        if (!this.fundsManager) return null;
        return this.fundsManager.getFundsStatus();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ EJECUCIÃ“N PRINCIPAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function main() {
    const configurator = new BinanceRealAccessConfigurator();
    
    try {
        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘        ğŸ”‘ CONFIGURADOR DE ACCESO REAL A BINANCE             â•‘');
        console.log('â•‘     SincronizaciÃ³n de Balance y ConfiguraciÃ³n Coherente     â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('');
        
        const result = await configurator.configure();
        
        console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘                    âœ… CONFIGURACIÃ“N COMPLETADA              â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        const status = configurator.getConfigStatus();
        console.log('\nğŸ“Š Estado final:');
        console.log(`   ğŸ’° Balance sincronizado: $${status.balance?.toFixed(2) || 'N/A'}`);
        console.log(`   ğŸŒ Binance conectado: ${status.binanceConnected ? 'SÃ' : 'NO'}`);
        console.log(`   ğŸ§  FundsManager configurado: ${status.configured ? 'SÃ' : 'NO'}`);
        console.log(`   ğŸ”— Modo: ${status.environment.testnet ? 'TESTNET' : 'PRODUCTION'}`);
        console.log('');
        
        process.exit(0);
        
    } catch (error) {
        console.error('\nğŸ’¥ Error en configuraciÃ³n:', error.message);
        process.exit(1);
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    main();
}

module.exports = BinanceRealAccessConfigurator;
