/*
  Script para solucionar el problema de carga de s√≠mbolos
  Conecta BinanceRealConnector con QuantumInfiniteCache para cargar s√≠mbolos reales
*/

const { BinanceRealConnector } = require('./quantum-core/BinanceRealConnector');
const QuantumInfiniteCache = require('./quantum-core/QuantumInfiniteCache');

class SymbolsLoader {
    constructor() {
        console.log('üîß Inicializando corrector de carga de s√≠mbolos...');
        
        // Inicializar conectores
        this.binanceConnector = new BinanceRealConnector();
        this.quantumCache = new QuantumInfiniteCache();
        
        console.log('‚úÖ Componentes inicializados');
    }
    
    async testBinanceConnection() {
        console.log('üß™ Probando conexi√≥n con Binance...');
        
        try {
            // Test b√°sico: obtener informaci√≥n de exchange
            const exchangeInfo = await this.binanceConnector.getExchangeInfo();
            
            if (exchangeInfo && exchangeInfo.symbols) {
                console.log(`‚úÖ Conexi√≥n exitosa - ${exchangeInfo.symbols.length} s√≠mbolos disponibles`);
                return true;
            } else {
                console.log('‚ùå No se pudo obtener informaci√≥n del exchange');
                return false;
            }
        } catch (error) {
            console.error('‚ùå Error conectando con Binance:', error.message);
            return false;
        }
    }
    
    async loadRealSymbols() {
        console.log('üìä Cargando s√≠mbolos reales desde Binance...');
        
        try {
            // 1. Obtener lista de s√≠mbolos de Binance
            const exchangeInfo = await this.binanceConnector.getExchangeInfo();
            
            if (!exchangeInfo || !exchangeInfo.symbols) {
                throw new Error('No se pudo obtener informaci√≥n del exchange');
            }
            
            // 2. Filtrar solo s√≠mbolos USDT de futuros activos
            console.log('üìã Analizando estructura de s√≠mbolos de futuros...');
            console.log('Ejemplo de s√≠mbolo:', JSON.stringify(exchangeInfo.symbols[0], null, 2));
            
            const futuresSymbols = exchangeInfo.symbols
                .filter(symbol => {
                    // Para Binance Futures, la estructura es diferente
                    return symbol.quoteAsset === 'USDT' && 
                           symbol.status === 'TRADING' &&
                           symbol.symbol.endsWith('USDT') &&
                           (symbol.contractType === 'PERPETUAL' || !symbol.contractType) // Filtrar perpetuos principalmente
                })
                .map(symbol => symbol.symbol)
                .slice(0, 350); // Cargar 350 s√≠mbolos principales
            
            console.log(`üéØ Seleccionados ${futuresSymbols.length} s√≠mbolos USDT activos`);
            
            // 3. Crear funci√≥n de fetch real
            const realFetchFn = async (symbol) => {
                try {
                    // Obtener datos de ticker de 24h
                    const ticker = await this.binanceConnector.get24hrTicker(symbol);
                    
                    if (!ticker) {
                        throw new Error(`No data for ${symbol}`);
                    }
                    
                    return {
                        symbol: ticker.symbol,
                        price: parseFloat(ticker.lastPrice),
                        volume: parseFloat(ticker.volume),
                        priceChangePercent: parseFloat(ticker.priceChangePercent),
                        high: parseFloat(ticker.highPrice),
                        low: parseFloat(ticker.lowPrice),
                        bidPrice: parseFloat(ticker.bidPrice || ticker.lastPrice),
                        askPrice: parseFloat(ticker.askPrice || ticker.lastPrice),
                        timestamp: Date.now(),
                        
                        // Calcular volatilidad basada en high/low
                        volatility: (parseFloat(ticker.highPrice) - parseFloat(ticker.lowPrice)) / parseFloat(ticker.lastPrice),
                        
                        // Datos adicionales
                        trades24h: parseInt(ticker.count || 0),
                        marketCap: parseFloat(ticker.lastPrice) * parseFloat(ticker.volume), // Aproximado
                    };
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error obteniendo datos para ${symbol}:`, error.message);
                    return null;
                }
            };
            
            // 4. Cargar s√≠mbolos en la cache
            console.log('üîÑ Iniciando precarga de s√≠mbolos reales...');
            
            const startTime = Date.now();
            const result = await this.quantumCache.preloadSymbols(
                futuresSymbols,
                realFetchFn,
                {
                    sequential: false,
                    timeout: 45000,  // 45 segundos timeout
                    maxConcurrency: 10, // M√°ximo 10 peticiones simult√°neas
                    ttl: 30000  // 30 segundos TTL
                }
            );
            
            const duration = Date.now() - startTime;
            
            console.log('‚úÖ PRECARGA COMPLETADA:');
            console.log(`   üìà Exitosos: ${result.succeeded}`);
            console.log(`   ‚ùå Fallidos: ${result.failed}`);
            console.log(`   ‚è±Ô∏è Duraci√≥n: ${(duration / 1000).toFixed(2)}s`);
            
            // 5. Verificar estado de la cache
            await this.displayCacheStatus();
            
            return result;
            
        } catch (error) {
            console.error('üí• Error cargando s√≠mbolos:', error);
            throw error;
        }
    }
    
    async displayCacheStatus() {
        console.log('');
        console.log('üìä ESTADO ACTUAL DE LA CACHE:');
        
        // Obtener m√©tricas de la cache
        const metrics = this.quantumCache.getMetrics();
        const health = this.quantumCache.validateSystemHealth();
        
        console.log(`   üíé S√≠mbolos cargados: ${this.quantumCache.quantumState.symbolsLoaded}`);
        console.log(`   üìà Hit rate: ${metrics.performance.hitRate}`);
        console.log(`   ‚ö° Latencia promedio: ${metrics.performance.avgLatency}`);
        console.log(`   üî• Precargas exitosas: ${metrics.performance.preloadSuccess}`);
        console.log(`   üéØ Estado del sistema: ${health.status}`);
        
        if (health.warnings && health.warnings.length > 0) {
            console.log(`   ‚ö†Ô∏è Advertencias: ${health.warnings.join(', ')}`);
        }
        
        // Mostrar algunos s√≠mbolos cargados como ejemplo
        const symbolsMap = this.quantumCache.tradingCache.symbols;
        if (symbolsMap.size > 0) {
            console.log('');
            console.log('üéØ S√çMBOLOS CARGADOS (ejemplos):');
            let count = 0;
            for (const [symbol, data] of symbolsMap.entries()) {
                if (count < 10) {  // Mostrar solo los primeros 10
                    const symbolData = data.data;
                    console.log(`   ${symbol}: $${symbolData.price?.toFixed(6) || 'N/A'} (${symbolData.priceChangePercent?.toFixed(2) || 'N/A'}%)`);
                    count++;
                }
            }
            if (symbolsMap.size > 10) {
                console.log(`   ... y ${symbolsMap.size - 10} m√°s`);
            }
        }
        
        console.log('');
    }
    
    async categorizeSymbols() {
        console.log('üè∑Ô∏è Categorizando s√≠mbolos...');
        
        const symbolsMap = this.quantumCache.tradingCache.symbols;
        const categories = {
            'Majors': [],
            'DeFi': [],
            'Gaming': [],
            'AI': [],
            'Layer1': [],
            'Layer2': [],
            'Meme': [],
            'Privacy': [],
            'Oracle': [],
            'Storage': [],
            'Infrastructure': [],
            'NFT': [],
            'Stablecoins': [],
            'RWA': [], // Real World Assets
            'Ex√≥ticos': []
        };
        
        // Definir patrones expandidos para categorizaci√≥n
        const patterns = {
            'Majors': ['BTC', 'ETH', 'BNB', 'XRP', 'ADA', 'SOL', 'DOGE', 'TRX', 'TON', 'AVAX', 'SHIB', 'DOT', 'LINK', 'BCH', 'LTC', 'NEAR', 'MATIC', 'ICP', 'UNI', 'APT'],
            'DeFi': ['UNI', 'SUSHI', 'CAKE', 'AAVE', 'COMP', 'MKR', 'YFI', 'CRV', '1INCH', 'SNX', 'DYDX', 'GMX', 'RUNE', 'ALPHA', 'BETA', 'AUTO', 'BAKE', 'BURGER', 'SXP', 'XVS', 'VAI', 'CREAM', 'FOR', 'BNT', 'KNC', 'LRC', 'ZRX', 'BAL', 'REN', 'FARM', 'HEGIC', 'PICKLE', 'COVER', 'VALUE', 'EPS', 'TRU', 'BADGER', 'DPI', 'FLI'],
            'Gaming': ['AXS', 'SAND', 'MANA', 'GALA', 'ENJ', 'CHZ', 'ALICE', 'TLM', 'SLP', 'PYR', 'ILV', 'WAXP', 'WIN', 'FUN', 'LOKA', 'C98', 'YGG', 'GHST', 'SKILL', 'THG', 'UFT', 'POLS', 'SUPER', 'NAKA', 'REVV', 'FLOW', 'MBOX', 'TOWER', 'GMT', 'GST', 'STEPN', 'MC', 'HERO', 'METIS', 'ATLAS', 'POLIS'],
            'AI': ['FET', 'OCEAN', 'AGI', 'NMR', 'GRT', 'CTXC', 'DPR', 'MDT', 'RNDR', 'PHALA', 'AI', 'ALI', 'CGPT', 'ARKM', 'WLD', 'TAO', 'AGIX', 'ORAI', 'HEART', 'PHB', 'MATRIX', 'DOCK', 'COTI', 'LPT', 'VIDT', 'DATA'],
            'Layer1': ['ETH', 'ADA', 'SOL', 'DOT', 'AVAX', 'ATOM', 'ALGO', 'NEAR', 'FTM', 'LUNA', 'EGLD', 'HBAR', 'ICP', 'VET', 'THETA', 'EOS', 'TRX', 'XTZ', 'WAVES', 'ONT', 'QTUM', 'ZIL', 'ICX', 'KAVA', 'BAND', 'CKB', 'RVN', 'DGB', 'SYS', 'NULS'],
            'Layer2': ['MATIC', 'LRC', 'IMX', 'METIS', 'BOBA', 'ARB', 'OP', 'STRK', 'MANTA', 'BLUR', 'DYDX', 'ZK', 'POLY', 'CELR', 'SKL', 'CTC'],
            'Meme': ['DOGE', 'SHIB', 'PEPE', 'FLOKI', 'BONK', 'WIF', 'MEME', 'BABYDOGE', 'ELON', 'AKITA', 'SHIBA', 'KISHU', 'SAMO', 'CATE', 'MYRO', 'BOME', 'SLERF', 'WEN', 'POPCAT', 'MEW', 'BRETT', 'NEIRO', 'TURBO', 'MAGA'],
            'Privacy': ['XMR', 'ZEC', 'DASH', 'TORN', 'SCRT', 'ROSE', 'NYM', 'DERO', 'BEAM', 'GRIN', 'FIRO'],
            'Oracle': ['LINK', 'BAND', 'TRB', 'API3', 'UMA', 'DIA', 'FLUX', 'PYR', 'NEST'],
            'Storage': ['FIL', 'STORJ', 'AR', 'SIA', 'BTT', 'HOT', 'SC', 'SAFE'],
            'Infrastructure': ['RNDR', 'FLUX', 'AKRO', 'NKN', 'POKT', 'HNT', 'IOTX', 'JASMY', 'MOBILE'],
            'NFT': ['BLUR', 'LOOKS', 'X2Y2', 'SUDO', 'NFT', 'WHALE', 'NFTX', 'RARI'],
            'Stablecoins': ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDP', 'FRAX', 'LUSD', 'FDUSD', 'USDD'],
            'RWA': ['RIO', 'POLYX', 'PROPS', 'RWA', 'LABS', 'ONDO']
        };
        
        for (const [symbol] of symbolsMap) {
            let categorized = false;
            
            for (const [category, tokens] of Object.entries(patterns)) {
                if (tokens.some(token => symbol.startsWith(token))) {
                    categories[category].push(symbol);
                    categorized = true;
                    break;
                }
            }
            
            if (!categorized) {
                categories['Ex√≥ticos'].push(symbol);
            }
        }
        
        console.log('');
        console.log('üóÇÔ∏è S√çMBOLOS POR CATEGOR√çA:');
        for (const [category, symbols] of Object.entries(categories)) {
            if (symbols.length > 0) {
                console.log(`   ${this.getCategoryEmoji(category)} ${category}: ${symbols.length}`);
                if (symbols.length <= 5) {
                    console.log(`      ${symbols.join(', ')}`);
                } else {
                    console.log(`      ${symbols.slice(0, 5).join(', ')} ... (+${symbols.length - 5})`);
                }
            }
        }
        
        return categories;
    }
    
    getCategoryEmoji(category) {
        const emojis = {
            'Majors': 'üëë',
            'DeFi': 'üîó',
            'Gaming': 'üéÆ',
            'AI': 'ü§ñ',
            'Layer1': '‚õìÔ∏è',
            'Layer2': 'üåâ',
            'Meme': 'üòπ',
            'Privacy': 'üîê',
            'Oracle': 'üîÆ',
            'Storage': 'üíæ',
            'Infrastructure': 'üèóÔ∏è',
            'NFT': 'üé®',
            'Stablecoins': 'üí∞',
            'RWA': 'üè¢',
            'Ex√≥ticos': 'üöÄ'
        };
        return emojis[category] || 'üìä';
    }
    
    async run() {
        console.log('üöÄ INICIANDO CORRECCI√ìN DE CARGA DE S√çMBOLOS');
        console.log('===============================================');
        
        try {
            // 1. Probar conexi√≥n
            const connected = await this.testBinanceConnection();
            if (!connected) {
                throw new Error('No se puede conectar con Binance');
            }
            
            // 2. Cargar s√≠mbolos reales
            await this.loadRealSymbols();
            
            // 3. Categorizar s√≠mbolos
            await this.categorizeSymbols();
            
            console.log('');
            console.log('‚úÖ CORRECCI√ìN COMPLETADA EXITOSAMENTE');
            console.log('üéØ Los s√≠mbolos ahora deber√≠an aparecer correctamente en el sistema');
            
        } catch (error) {
            console.error('üí• ERROR EN LA CORRECCI√ìN:', error.message);
            throw error;
        }
    }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
    const loader = new SymbolsLoader();
    
    loader.run()
        .then(() => {
            console.log('');
            console.log('üéâ Proceso completado - s√≠mbolos cargados exitosamente');
            process.exit(0);
        })
        .catch((error) => {
            console.error('');
            console.error('üí• Error fatal:', error.message);
            process.exit(1);
        });
}

module.exports = { SymbolsLoader };
